[{"slug":"2021-02-11-webpack-snowpack","title":"Webpack 보다 더 빠른 빌드툴, Snowpack","body":"🚨 Update\n\nSnowpack과 유사한 컨셉의 Vite를 추천하는 이유\n\nSnowpack\n\n스노우팩은 unbundled during development 즉 개발중에 번들링을 하지 않겠다는 컨셉의 프론트엔트 빌드툴이다.\n\nUnbundled Development\n\n\n예를들면 현재 빌드툴로 가장 많이 사용되는 webpack 같은 경우, 파일 하나가 변경될 경우 연관된 모든 파일을 다시 빌드하고 다시 번들링 해야 한다. 그래서 시간 복잡도를 O(n) 으로 가져가야 한다.\n스노우팩은 개발중에 모든 파일들을 단일 파일로 빌드하고 esm 방식으로 import 한다. 만약 어떤 파일이 변경되면 그 파일만 새로 빌드된다. 즉 O(1) 빌드 시스템인 셈이다.\n\nnpm 패키지의 경우 CommonJS 구문으로 작성되어 있을수도 있기 때문에 개발자가 직접 작성하는 파일처럼 패키지 내 모든 파일들이 하나하나 import 되지 않고, 아래와 같이 단일 파일로 빌드해서 import 한다.\n\nnode\\_modules/react/\\*\\*/\\* -> http://localhost:3000/web\\_modules/react.js > node\\_modules/react-dom/\\*\\*/\\* -> http://localhost:3000/web\\_modules/react-dom.js\n\nCreate Snowpack App\n\nCreate React App 처럼 을 제공하기 때문에 좀더 쉽게 접할 수 있다. 확장성이 떨어지는 zero-config를 추구하는 CRA와는 달리,  라는 파일이 존재하고 이 파일을 기반으로 커스텀이 가능하다. 그렇지만 webpack.config.js 보다는 훨씬 다루기가 쉽다!\n특이한 점은 기본 테스트 라이브러리로 jest가 아닌 @web/test-runner을 채택했다. 물론 jest도 사용할 수 있지만, 자체 테스트에서 @web/test-runner가 성능이 더 좋았다고 한다.\n\nesbuild\n\n\nesbuild는 go로 쓰여진 자바스크립트 번들러로 자체 벤치마크상에서 webpack보다 100배 이상의 성능을 낸다고 내걸고 있다. 스노우팩은 내부적으로 esbuild를 단일파일빌더로 사용하고 있는데, 스노우팩 V3부터는 esbuild 기반 내장 빌드 최적화 파이프라인을 지원한다. 여기서 최적화 파이프라인이라는 것은 production을 위한 최종 빌드 과정에서 bundle, minify, code splitting, treeshake, targetting, preload 등을 하는 것이다. 이렇게 스노우팩은 esbuild를 활용해서 자바스크립트라는 언어의 성능상 한계를 극복하려고 한다. 다만, 아직 esbuild 자체가  이다보니 스노우팩도 큰 규모의 프로젝트에서는  사용을 권장하고 있다.\n\n정리\n\n스노우팩이 아직 완벽하게 웹팩을 대체할 수 있는 건 아니다. FE개발자들이 많이 사용하는 스토리북이 웹팩 기반이기도 하고 (같이 사용하기엔  매칭이 복잡함) esbuild가 React17의 JSX Transform을 지원하지 않는 문제도 있다. 그럼에도 에서 webpack을 제치고 매우 높은 만족도를 얻은 점도 그렇고 unbundled development라는 컨셉도 그렇고 상당히 기대가 되는 빌드툴인 것 같다. 현재 레포가 그다지 큰 프로젝트도 아닌데 fast refresh 속도나 스토리북이 실행되는 속도가 썩 빠르지 않은지라 스노우팩의 등장이 더욱더 흥미진진하다. 개인적으로는 토이플젝에서 자주 쓰게 될 것 같다.\n"},{"slug":"2021-02-13-framer-motion-react-motion-gesture","title":"framer-motion : react를 위한 motion & gesture 라이브러리","body":"framer-motion는 리액트에서 애니메이션과 제스쳐를 쉽게 다룰 수 있도록 해주는 라이브러리다. animate props에 값을 세팅하면 CSS transitions를 자동생성하는 방법으로 애니메이션을 만들어주고, drag나 hover 등의 제스쳐를 지원해주기도 하고, 단일 애니메이션 prop으로 하위 트리까지 이어지는 애니메이션을 적용할 수도 있다.\n\n설치\n\nmotion은 다음과 같이 설치하고 선언해서 사용할 수 있다.\n\nmotion components\n\nmotion.div, motion.svg 이렇게 html 요소나 svg 요소에 대응할 수 있는 컴포넌트로 다른 부분은 스태틱 요소와 동일하나 애니메이트, 제스쳐 등을 설정할 수 있다.\n\ntransform 속성으로 CSS 애니메이션을 구현하면 브라우저가 GPU를 활용하기 때문에 left 대신 x 옵션을 사용하는 것이 더 빠르다고 한다.\n\n사용예시\n\nAnimation\n\nanimate prop는 값을 객체로 받고 이 값이 지정되면 첫 렌더링시에, 또는 변경되면 변경된 값으로 motion 컴포넌트를 애니메이팅 한다. 예를 들면 위의 motion 컴포넌트는 div 엘레먼트로 렌더링 되면서 두 배로 확대된다.\n\nKeyframes\n\n값을 array로 넣게 되면 순서대로 실행된다. 기본적으로는 동일한 시간으로 실행되나 transition 프로퍼티를 조정해서 시간값을 수정할 수 있다.\n\nVariants\n\nvariants props를 활용하면 선언적 방법으로 돔 전체에 전파되는 애니메이션을 만들 수도 있다. 예를 들면 위와 같은 컴포넌트에서는 animate가 open일 경우 motion.nav와 motion.ul의 variants 값 중 open값들이 실행된다.\n\nGesture\n\nmotion 컴포넌트는 whileHover이나 whileTap같은 제스처 헬퍼 props를 가지고 있다.\n\nDrag\n\n위과 같은 방법으로 드래그가 가능한 요소를 지정할 수 있고 드래그 가능한 영역도 ref를 넘겨주거나 top, left 등을 특정 값으로 넘겨서 지정할 수 있다.\n\nMotionValues\n\nmotion은 MotionValue를 애니메이션을 제어하는데 사용하는데 이것을 훅을 통해 직접 사용할 수도 있다. 위의 코드에서는 내부 motion 컴포넌트를 드래그 했을때 x가 변경되면서 background 색상도 변경된다.\n\nViewport scroll\n\nuseViewportScroll 훅은 스크롤 관련 MotionValues를 제공하므로 이를 motion 컴포넌트와 결합해서 활용할 수 있다.\n\n정리\n\n여기에 적기엔 너무 많은 기능이 있는 라이브러리라 다 적기가 어렵다. 자세한 기능은 라이브러리의 를 참고하면 좋을 것 같다. 프론트엔드 개발을 하면서도 css 애니메이션은 다소 단순한 트랜지션만 적용하곤 했는데, 이런 라이브러리를 활용하면 상태관리나 렌더링에 대해 덜 신경쓰면서 유저에게 더 감각적인 ui/ux를 제공할 수 있지 않을까 싶다. 이런 라이브러리들을 보면 수준 높은 프론트엔드 개발을 하려면 js도 중요하지만 css를 더 잘 알아야겠다고 생각하게 되는 것 같다ㅠㅠ\n"},{"slug":"2021-03-08-browser-rendering","title":"브라우저 렌더링에 대한 이해와 최적화","body":"브라우저 아키텍처\n\n\n브라우저 엔진 : 유저 인터페이스와 렌더링 엔진 사이의 중개자로, 유저 인터페이스에서 받은 입력에 따라 렌더링 엔진을 쿼리하고 처리한다.\n렌더링 엔진 : HTML/CSS를 파싱해서 사용자가 요청한 특정 웹 페이지를 화면에 렌더링하는 역할을 한다.\n\n렌더링 엔진이 하는 일\n\n\n\n브라우저는 HTML 소스코드를 파싱하고 DOM tree를 만든다.\n\n브라우저가 CSS 코드를 파싱한다.\n\nrender tree를 생성한다. render tree는 styles를 알고 있기 때문에 display: none 이거나 \\<head> 처럼 보이지 않는 요소는 포함되지 않는다.\n\nrender tree가 생성되면 브라우저는 render tree 노드들을 paint 할 수 있다.\n\nscript, stylesheet\n\n스크립트\n\n스크립트가 실행되는 동안 문서의 파싱은 중단된다.\n\ndefer로 표시하면 문서 파싱이 완료된 후 실행된다.\n\nasync로 표시하면 비동기로 실행된다.\n\n스타일시트\n\n스타일시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 중단하지 않는다.\n\nRepaint & Reflow & Composite\n\n\n\nreflow (layout) : render tree의 일부는 revalidated / recalculated 되어야 한다.\n\nposition(위치)이나 geometries(기하학적 요소) 재계산\n\nreflow는 user-blocking operation이므로 최적화를 위해 이에 대한 이해가 필요하다.\n\nrepaint (redraw) : 노드 위치 변경 또는 스타일 변경에 의해 화면에서 업데이트 되어야 한다.\n\nvisibility 변경, outline 변경, background 변경 등에 의해 발생한다.\n\npaint는 픽셀 파이프라인에서 가장 비용이 많이 드는 부분이므로 레이어 승격 또는 애니메이션 orchestration을 통해 최적화 하는 것이 좋다.\n\ncomposite : 화면에 표시하기 위해 페이지에서 paint 된 부분을 합치는 과정이다.\n\ntransform 또는 opacity 변경에 의해 발생한다.\n\nwill-change 또는 translateZ를 사용해서 요소를 자체 레이어로 승격할 수 있다.\n\nwill-change 속성을 사용하면 해당 레이어는 GPU에 업로드된다.\n\n\n\nhttps://csstriggers.com/ 에서 브라우저 엔진 별로 layout / paint / composite를 발생시키는 css properties를 확인할 수 있다. Webkit - Safari, Blink - Chrome, Gecko - Firefox, EdgeHTML - 구Edge다.\n\n참고\n\nhttps://medium.com/swlh/what-the-heck-is-repaint-and-reflow-in-the-browser-b2d0fb980c08\n\nhttps://d2.naver.com/helloworld/59361 (https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)\n\nhttps://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg\n\nhttps://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count\n\nhttps://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/\n"},{"slug":"2021-03-09-web-worker-service-worker","title":"Web Worker와 Service Worker","body":"브라우저는 자바스크립트를 실행하기 위해서 싱글 스레드를 사용하므로 거대한 자바스크립트 코드를 돌리면 메인 스레드가 block 되고 사용자 경험이 악화될 것이다. 앱에서 다중 스레딩 모델을 사용하는 것 처럼, 웹에서는 Worker를 사용해서 백그라운드 스레드에서 스크립트를 실행할 수 있다.\n\nWeb Worker와 Service Worker\n\n공통점\n\n추가 스레드에서 실행되므로 메인 스레드를 블록하지 않고 실행될 수 있다.\n\nWindow나 Document 객체에 접근할 수 없어서 DOM과 직접적으로 interact 할 수 없고 browser API에 접근하는데 한정적이다.\n\n차이점\n\n서비스 워커는 fetch event와 같은 네트워크 요청을 탈취하거나 push event와 같은 Push API를 listen 할 수 있다.\n\n페이지는 여러개의 웹 워커를 생성할 수 있지만, 단일 서비스 워커는 등록된 scope내에서 모든 활성 탭을 제어한다.\n\n웹 워커의 수명은 자신이 속한 탭과 밀접하게 결합되는 반면, 서비스 워커의 수명은 독립적이다. 따라서 웹 워커가 실행중인 탭을 닫으면 워커가 종료되지만, 서비스 워커는 활성 탭이 열려있지 않아도 백그라운드에서 계속 실행될 수 있다.\n\n사용 사례\n\nWeb Workers\n\n웹 워커는 주로 UI block을 피하기 위해 무거운 연산이 소요되는 작업(AI, games, image encoding, etc)을 보조 스레드에서 실행하기 위해 사용된다.\n\n\n\n&#x20;: off the main thread (OMT) 아키텍처를 리액트에서 구축하는 방법\n\n\n\nService Workers\n\n서비스 워커는 일반적으로 네트워크 프록시 같은 역할이나 백그라운드 작업, 캐싱, 오프라인을 처리하는데 사용된다.\n\n\n\n\n\n&#x20;: Window to Service Workers 사례\n\n&#x20;: 페이지에서 서비스워커를 호출하여 리소스를 미리 캐싱\n\n참고\n\nhttps://web.dev/workers-overview/\n\nhttps://developers.google.com/web/fundamentals/primers/service-workers\n"},{"slug":"2021-03-09-web-vital","title":"웹사이트 성능 메트릭","body":"주요 metrics(지표) 항목\n\n\n\n⭐️ 표시는 Web Vital에서 중점적으로 체크하는 항목이다.\n\nLCP : 로딩 성능\n\nFID : 상호 작용력\n\nCLS : 시각적 안정성\n\nTTFB (Time To First Byte)\n\n페이지를 요청했을 때 서버에서 데이터의 첫 번째 바이트가 도착하는 시점을 나타낸다. TTFB는 주로 서버 성능과 직결된다.\n\n최적화 방법\n\n서버 애플리케이션 로직 최적화\n\nDB 쿼리 최적화 또는 더 빠른 DB로 마이그레이션\n\n더 많은 RAM 또는 CPU를 갖도록 서버 하드웨어 업그레이드\n\nFCP (First Contentful Paint)\n\n\nFCP는 페이지가 로드되기 시작하고 컨텐츠의 일부가 화면에 렌더링 될 때 까지의 시간을 의미한다.\n\n최적화 방법\n\n렌더링을 block 하는 리소스 제거\n\nCSS minify\n\n사용하지 않는 CSS 제거\n\n요청할 origin에 preconnect : \\<link rel=\"preconnect\">\n\n서버 응답 시간 (TTFB) 줄이기\n\n여러 페이지 리다이렉트 줄이기\n\n키 요청 preload : \\<link rel=\"preload\">\n\n지나치게 큰 네트워크 payload를 피하기\n\n효율적인 캐시 정책으로 정적 자산 제공\n\n과도한 DOM size를 피하기\n\n중요한 요청의 depth를 최소화\n\n웹 폰트 로드 중에 텍스트가 계속 보이도록 함\n\n요청 수를 줄이고 전송 크기를 작게 하기\n\nFMP (First Meaningful Paint)\n\n브라우저가 페이지의 주요 컨텐츠들을 화면에 렌더링하기 시작하는 순간이다. 다만, FMP는 페이지 로드의 작은 차이에 지나치게 민감하기 때문에 일관성이 떨어져서 LCP를 측정하는 것을 권장하고 있다.\n\n⭐️ LCP (Largest Contentful Paint)\n\n\n페이지에서 가장 용량이 큰 컨텐츠가 표시되는 시점을 나타낸다. FCP의 경우 페이지에 스플래시 화면이 표시되거나 로딩중 아이콘이 표시되는 경우도 포함하기 때문에 사용자와 그다지 관련이 없다. FMP를 측정하는 것이 복잡하기 때문에 가장 용량이 큰 컨텐츠가 렌더링 되는 시기인 LCP를 주요 컨텐츠가 로드되는 시기로 판단하는 것을 권장하고 있다.\n\n\n최적화 방법\n\n느린 서버 응답 시간 해결\n\n서버 최적화\n\n가까운 CDN으로 라우팅\n\nasset 캐싱\n\ncache-first HTML 페이지 서빙\n\n서드파티 origin 리소스 preconnect\n\n렌더링을 block 하는 JS 및 CSS 해결\n\nCSS block 시간 단축\n\nCSS minify\n\n중요하지 않은 CSS는 defer로 load\n\n중요 CSS는 inline 으로 load\n\nJavascript block 시간 단축\n\nJS 파일 minify 및 압축\n\n느린 리소스 (img, svg, video, ...) 로드 시간 해결\n\n이미지 최적화 및 압축\n\n중요한 리소스 preload\n\n텍스트 파일 압축\n\n적응형 리소스 서빙\n\n예: 네트워크가 느린 경우 video 대신 image 서빙\n\n서비스 워커를 통한 자산 캐싱\n\n클라이언트 사이드 렌더링의 경우\n\n중요한 자바스크립트 최소화\n\n자바스크립트 minify\n\n사용하지 않는 자바스크립트 defer로 load\n\n사용하지 않는 polyfill 최소화\n\n서버사이드 렌더링 사용\n\nTTFB 증가, TTI 증가를 고려해야 함\n\npre-rendering 사용\n\nTTI는 증가할 수 있으나 TTFB는 SSR보다 나음\n\n⭐️ CLS (Cumulative Layout Shift)\n\n\n페이지가 로드되기 시작하는 시점과 lifecycle 상태가 숨김으로 변경되는 시점 사이에 발생하는 모든 예기치 않은 레이아웃 이동의 누적 점수를 측정한다. 일반적으로 리소스가 비동기적으로 로드되거나 DOM 요소가 기존 컨텐츠가 있는 페이지에 동적으로 추가될 때 발생한다.\n\n최적화 방법\n\n이미지나 동영상 요소에 크기를 미리 지정하거나 임시 박스같은 것으로 필요한 공간을 확보\n\n사용자 interactive 응답 외에 기존 컨텐츠 위에 컨텐츠를 넣지 않기\n\nlayout 변경을 트리거하는 css property보다 transform 애니메이션을 사용\n\nTTI (Time To Interactive)\n\n웹 페이지가 완전히 상호작용이 가능(interactive)하게 되는 시점을 나타낸다. 컨텐츠를 볼 수 있지만 스크롤 할 수 없거나 항목을 클릭해도 효과가 없으면 interactive 하지 않은 것이다.\n\n최적화 방법\n\nJS minify\n\n요청할 origin에 preconnect : \\<link rel=\"preconnect\">\n\n키 요청 preload : \\<link rel=\"preload\">\n\n타사 코드의 영향 범위 감소\n\n중요한 요청의 depth를 최소화\n\nJS 실행시간 단축\n\n메인 스레드 작업 최소화\n\n요청 수를 줄이고 전송 크기를 작게 유지\n\n⭐️ FID (First Input Delay)\n\n\n사용자가 페이지와 처음 상호작용한(클릭 또는 키 입력 등) 시간부터 브라우저가 실제로 이벤트 핸들러 처리를 시작할 수 있는 시간까지의 시간을 측정한다.\n\n일반적으로 입력 지연은 브라우저의 기본 스레드가 다른 작업 (예: 대용량 js 파일 파싱)을 실행 중일때 발생한다. 위와 같이 메인 스레드에서 작업중인데 user input이 발생하면 브라우저가 이에 대응하는데 FID만큼의 시간이 소요된다.\n\n최적화 방법\n\n긴 Tasks 분할하기\n\n메인 스레드를 50ms 이상 차단하는 긴 Task를 분할하기 (TBT 개선)\n\n코드 스플리팅\n\n상호작용 준비를 위한 페이지 최적화\n\nJS 코드 및 기능을 점진적으로 load\n\nSSR의 경우 논리를 서버측으로 이동하고 코드 스플리팅을 고려해야 함\n\ncascading data fetch를 최소화\n\n서드파티 코드 로딩시간 고려해야 함\n\nweb worker 사용하기\n\n백그라운드 스레드에서 자바스크립트를 실행할 수 있음\n\nJS 실행시간 단축\n\n사용하지 않는 자바스크립트 defer로 load\n\n특별한 이유가 없는 한 서드파티 스크립트는 defer 또는 async로 로드되어야 함\n\n사용하지 않는 polyfill 최소화\n\nmodule / nomodule 패턴을 활용하여 개별 번들 제공\n\nTBT (Total Blocking Time)\n\n\nTBT는 주 스레드가 input 응답을 막을 정도로 오래 차단 되었을때 FCP와 TTI 사이의 총 시간을 나타낸다. 긴 작업의 차단 시간은 50ms를 초과하는 시간으로 계산한다. 즉 task의 작업 시간이 250ms이면 TBT는 200ms이다.\n\n최적화 방법\n\n타사 코드의 영향 범위 감소\n\nJS 실행시간 단축\n\n메인 스레드 작업 최소화\n\n요청 수를 줄이고 전송 크기를 작게 유지\n\nSSR과 CSR에서의 성능 메트릭\n\n\n\nSSR (Server Side Rendering)\n\nSSR은 일반적으로 빠른 FP와 FCP를 가진다. 또한 많은 JS를 서버단에서 실행하므로 TTI도 빠르게 수행할 수 있다. 다만 서버에서 페이지를 생성하는데 시간이 걸리기 때문에 TTFB가 느려질 수 있다.\n\nSSR with hydration\n\n유려한 페이지 전환과 인터랙션을 위해 첫 페이지 렌더는 SSR, 이후에는 CSR로 이루어지는 SSR with hydration이라는 기법도 존재한다. Next.js를 활용하면 쉽게 구현할 수 있다.\n\nCSR (Client Side Rendering)\n\nCSR에서는 리소스를 가져오기만 하면 되기 때문에 빠른 TTFB를 가진다. 하지만 FCP가 느리고 자연히 TTI는 그보다 더 느리다는 단점이 있다.\n\n측정방법\n\nlab : 개발하면서 테스트\n\n\n\n\n\n\n\nfield : 실제 사용자 모니터링\n\n를 통한 추적\n\n\n\n참고\n\nhttps://github.com/csabapalfi/awesome-pagespeed-metrics\n\nhttps://web.dev/user-centric-performance-metrics/\n\nhttps://developers.google.com/web/updates/2019/02/rendering-on-the-web\n\nhttps://markoskon.com/performance/\n"},{"slug":"2021-03-13-ecmascript-2021","title":"ECMAScript 2021","body":"1. String.prototype.replaceAll\n\n2. Promise.any()\n\nPromise.all()이 모든 promise들이 resolve 되면 resolve 되는 함수라면, Promise.any()는 하나라도 resolve 된다면 resolve 된다.\n\n3. WeakRef\n\nWeakRef 인스턴스는 등록한 객체가 메모리에 있으면 해당 객체를 반환하고, 가비지 콜렉터가 객체를 삭제했다면 undefined를 반환한다.\n\nFinalizationRegistry 인스턴스는 등록한 객체가 가비지 콜렉티드 되면 콜백 함수를 실행한다.\n\n4. Logical assignment operators (??=, &&=, ||=)\n\na += 3처럼 ??, &&, ||도 할당 연산자를 사용할 수 있다.\n\n5. Separators for numeric literals (1\\_000)\n\n숫자가 커질수록 자릿수 구분이 어려운데 \\_로 구분을 넣을 수 있다.\n\n참고\n\nhttps://tc39.es/ecma262/2021/\n"},{"slug":"2021-03-13-progressive-web-app","title":"Progressive Web App","body":"Progressive Web App이란?\n\n웹 앱 : 모든 사람들, 모든 장소, 모든 디바이스에서 접속이 가능하다.\n\n플랫폼 네이티브 앱 : 하드웨어에 접근할 수 있고 기기 데이터와 상호작용할 수 있는 등 장치의 기능을 활용할 수 있다. 설치할 수 있으므로 오프라인에서도 동작한다.\n\nPWA (Progressive Web App) 는 모던 API로 구축되어 네이티브 앱처럼 기능성, 안정성을 제공하는 것과 동시에 웹 앱처럼 모든 사람, 모든 장소, 모든 디바이스에서 접근할 수 있도록 개발된 웹 앱을 말한다.\n\nPWA 요소\n\n유능함\n\n웹은 그 자체로도 다양한 기능을 갖추고 있다. 예를 들면 WebRTC, Geolocation API, Push notification 등을 활용하면 비디오 채팅 앱을 개발할 수 있다. Web Assembly가 등장하면서 개발자는 C, Rust로 작업한 기능들을 웹에 적용할 수도 있다.\n\n신뢰할 수 있음\n\nPWA는 네트워크 속도에 관계 없이 빠르고 신뢰할 수 있어야 한다. 페이지 로드가 빨리 되어야 하고, 버튼 클릭이 오류 없이 동작해야만 하며, 버벅이는 증상이 없어야 한다. 또한 사용자는 네트워크가 느리거나 오프라인이더라도 앱이 정상적으로 나오거나 문제가 있음을 넌지시 알려주길 원한다. Service Worker과 Cache API를 활용하면 네트워크 독립적인 앱 개발이 가능하다.\n\n\n\n\n\n\n\n설치 가능함\n\n설치된 PWA는 브라우저 탭 대신 독립 실행형 창 위에서 실행될 수 있다.\n\n발견이 가능함\n\n검색엔진을 통해 찾을 수 있다. \\<meta> 태그를 사용하여 메타 데이터를 지정하거나, web app manifest를 정의하면 된다.\n\n\n\n연결 가능함\n\nURL으로 공유가 가능해야 한다. 앱 스토어에서 설치하지 않아도 URL만으로도 앱에 연결할 수 있는 것이 웹의 장점이다.\n\nprogressive (점진적이어야 함)\n\n구형 브라우저에서도 기본적으로 접근은 가능해야 하고, 신형 브라우저에서는 모든 기능을 제공할 수 있어야 한다.\n\nRe-engageable (재참여가능)\n\n새 컨텐츠가 있을때 알림을 보낼 수 있다. Web Push API와 Notifications API를 활용하면 이 작업을 수행할 수 있다.\n\n\n\n참고\n\nhttps://web.dev/what-are-pwas\n\nhttps://developer.mozilla.org/ko/docs/Web/Progressive\\_web\\_apps\n\nhttps://serviceworke.rs\n\nhttps://create-react-app.dev/docs/making-a-progressive-web-app\n"},{"slug":"2021-03-14-finite-state-machine","title":"Finite State Machine","body":"FSM\n\nFinite State Machine(FSM)은 유한한 개수의 상태를 가질 수 있는 automata이다. 이런 오토마타는 한 번에 오로지 하나의 상태만을 가지고, 어떠한 event에 의해 한 상태에서 다른 상태로 변경될 수 있으며 이를 Transition이라고 한다. 게임 로직에서 많이 사용되는 디자인 패턴이라고 한다.\n\n가장 흔히 접할 수 있는 케이스가 data fetching 모델 인 것 같다. idle 상태(State)였다가 클릭 이벤트(Event)가 일어나면 fetching 상태로 변경(Transition)되고, 실패시 error 상태로 변경되며 성공시 다시 idle 상태로 변경된다. error 상태에서 재시도하면 fetching 상태로 변경된다. 여기서 상태는 3개이며, 한 시점에서는 하나의 상태만 가질 수 있다.\n리액트 컴포넌트를 FSM으로 모델링하면 event는 사용자, 서버, 컴포넌트 props 등에 의해 제공되고 출력은 컴포넌트 렌더링이 될 것이다.\n\nxstate\n\nxstate는 FSM을 구현할 수 있는 자바스크립트 / 타입스크립트 기반 라이브러리다. 대표적으로 gatsby에서 사용하고 있는 듯 하다.\n\n계층 구조 state machine 구현\n\n\n\n운전자 기준 신호등의 경우, 신호등이 빨간불(red)이 되면 횡단보도 신호가 walk로 변경되고, 일정 시간 후 카운트다운을 하는 wait로 변경되었다가 PED\\_TIMER 후 stop으로 전환된다. stop이 되면 TIMER 후 green으로 변경되는 구조다.\n\n참고\n\nhttps://tech.okcupid.com/modeling-ui-states-in-react-form-component-using-finite-state-machine/\n\nhttps://xstate.js.org/docs/\n"},{"slug":"2021-03-14-intersection-observer-api","title":"Intersection Observer API","body":"Intersection Observer API는 타겟 요소와 상위 요소 or 최상위 Document의 Viewport 사이의 교차점 내의 변화를 비동기적으로 관찰하는 방법이다. 페이지 스크롤에 의한 lazy loading, 무한 스크롤, 스크롤에 따라 강조되는 table of contents, 광고 가시성 등의 구현을 할 때 유용하게 사용할 수 있다. 이걸 직접 구현하려면 해당 엘레먼트의 offset와 스크롤 이벤트 등을 사용해야 하는데 이러면 모든 코드가 메인 스레드에서 실행되기 때문에 성능 문제를 야기할 수 있다. Intersection Observer API는 타겟 요소가 다른 요소에 들어가거나 나갈 때 or 지정한 만큼 두 요소의 교차 부분이 변경될때마다 실행되는 콜백 함수를 등록할 수 있다.\n\nIntersection Observer 생성 및 적용\n\nroot: 대상 객체의 가시성을 확인할 때 사용되는 뷰포트 요소. root를 지정할 경우 반드시 대상 객체의 조상 요소여야 하며, 기본값은 브라우저의 Viewport 이다.\n\nrootMargin: root가 가진 여백\n\nthreshold: 콜백이 실행될 대상 요소의 가시성 percentage. 50% 만큼 요소가 보일때 탐지하고 싶으면 0.5로 지정하면 된다. 기본값은 0이며 이는 요소가 1px이라도 보이면 콜백이 실행됨을 의미한다.\n\nobserverInstance.observe(targetElement)로 타겟을 지정함과 동시에 콜백이 한번 실행되고, 이후 지정된 threshold에 해당될 때마다 콜백이 실행된다.\n\nIntersectionObserver는 탭 전환을 관찰할 수 없으므로 만일 타겟 요소가 Viewport에 보여지는 시간 등을 체크해야 하는 경우엔 visibilitychange를 함께 활용해야 할 것이다.\n\n호환성\n\n\n아쉽지만 생각보다 많은 브라우저에서 지원을 안 한다.\n공식 이 존재하므로 포함시켜주는것이 좋다.\n\n여담\n\n라는 훌륭한 래퍼 라이브러리가 있는데, 사용성이 뛰어나다.\n\n참고\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Intersection\\_Observer\\_API\n"},{"slug":"2021-03-14-mutation-observer","title":"Mutation Observer","body":"MutationObserver는 DOM 변경 감시를 제공한다. DOM을 감시하다가 child 노드들이나 attributes, data 등이 변경되면 콜백을 실행한다.\n예를 들면 prefers-color-scheme 미디어쿼리가  에서 다크모드를 적용하려면 보통 \\<body>의 class에 darkmode 같은 className을 추가하는 방식을 쓰곤 하는데, 만일 특정 컴포넌트에서 이 className 변경을 감지하고 javascript 함수를 실행하길 원한다면 이 API를 사용하면 된다.\n\nMutationObserver 생성 및 적용\n\nMutationObserver 인스턴스는 타겟 등록과 동시에 callback을 실행하지 않으므로, 만약 초기 실행을 원한다면 추가로 실행하는 과정이 필요하다.\n\n호환성\n\n\n호환이 많이 되는 편이여서 ie구버전을 지원해야 하는 경우가 아니라면 polyfill 적용은 필요없을 것 같다.\n\n참고\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n"},{"slug":"2021-03-14-resize-observer-api","title":"Resize Observer API","body":"Resize Observer API는 요소의 크기 변화를 감지하고 콜백을 실행한다. 기존에는 Viewport 크기 변화는 window의 resize 이벤트 또는 window.matchMedia로 감지할 수 있지만 요소의 크기 변화를 직접적으로 감지할 수 있는 방법은 없었다. 이 API를 이용하면 브라우저 크기 변화에 의존하지 않고 요소의 크기 변화를 직접적으로 관찰하고 대응할 수 있다.\n\nResize Observer 생성 및 적용\n\n는 에서 padding과 border를 뺀 값이다.\n\n호환성\n\n\n아직 호환성이 많이 아쉬운 API다. 특히 ios safari 기준 13.7(2020년 이후 업데이트) 이상이어야 대응하므로 사용에 주의가 필요하다.\n\n참고\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Resize\\_Observer\\_API\n"},{"slug":"2021-03-14-screen-capture-api","title":"Screen Capture API","body":"Screen Capture API를 통해 화면 또는 화면의 일부를 선택하고 미디어 스트림으로 캡쳐할 수 있다. 화면을 캡쳐하는 API이므로 디바이스의 input을 캡쳐하는 WebRTC API와 구분이 필요하다.\n\nScreen Capture API 사용법\n\ngetDisplayMedia의 옵션은  객체로 audio, video 옵션을 각각 지정할 수 있다. audio, video는 boolean 또는  값을 가진다.\ngetDisplayMedia는 resolve시 MediaStream 객체를 반환하는 Promise를 리턴한다. 이 MediaStream은 오디오 또는 비디오 트랙을 나타내는 0개 이상의 객체로 구성된다.\nImageCapture API를 사용하면 스냅샷을 캡쳐하는 것도 가능하다.\n\n호환성\n\n\n사실상 모바일은 지원하지 않는다...\n크롬 익스텐션이나 일렉트론에서 활용하면 좋을 것 같다.\n\n참고\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Screen\\_Capture\\_API\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/MediaStream\\_Image\\_Capture\\_API\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Media\\_Streams\\_API\n"},{"slug":"2021-03-14-void(0)","title":"void(0)","body":"void\n\n드물게 보이는 void(0)은 뭘까 검색해보니\n\n라고 한다.\n\n재밌는건 void 0(6 bytes)이 undefined(9 bytes)보다 바이트를 덜 먹기 때문에 uglifyjs같은 minifier에서 undefined를 void 0으로 바꾸는 경우가 있는 것 같다.\n\n화살표 함수에서 중괄호 없이 바로 반환할 때 함수의 결과값(아래에서는 func1()의 결과값 1)을 사용하지 않도록 선언할 때도 쓰일 수 있다.\n\n참고\n\nhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/void\n"},{"slug":"2021-03-21-code-spell-checker","title":"Code Spell Checker","body":"Code Spell Checker는 맞춤법 검사기 for vscode이다.\n\n과제를 평가하다보면 가끔 코드에 오타가 보이곤 한다. 이런 오타들은 코드의 신뢰성을 떨어트리고, typescript를 사용하지 않는 경우 오타 때문에 헤메는 경우가 있다. 하지만 우리는 한국인이기 때문에 전번화호가 잘못 입력된건 쉽게 파악할 수 있지만 phaneNomber에서 오타를 찾기 어려울때가 있다.\n\nvscode extension 중에 영문 스펠링 체크를 해주는 확장 프로그램이 있다.\nhttps://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\n\n\n\nCode Spell Checker는 스펠링이 잘못된 단어에 파란색 warning을 띄워주기 때문에 오타를 쉽게 발견할 수 있다. 오타 뿐만이 아니라 noncompare 같은 없는 단어도 알려주기 때문에 영알못에게 큰 도움이 된다.\n"},{"slug":"2021-03-21-prettier-eslint","title":"prettier와 eslint를 구분해서 사용하자","body":"Prettier와 eslint\n\nPrettier는 formatter고 eslint는 linter이다. 두 개의 차이점과 사용법을 알아야 더 스마트하게 사용할 수 있다.\n\n결론부터 말하자면 오류를 잡으려면 린터, 스타일을 교정하려면 포맷터를 사용하자.\n\n린터 룰은 크게 포맷팅(스타일) 룰과 코드 퀄리티 룰이라는 두가지 카테고리로 나눌 수 있다. 사용되지 않은 변수를 오류로 분류하는 no-unused-vars 같은 코드 퀄리티 룰은 prettier 같은 포맷터가 잡아낼 수 없다. prettier는 코드 포맷팅에 특화되어 있으므로 eslint가 할 수 없는 최대 글자 길이에 맞춘 자동 포맷팅을 할 수 있다.\n\nPrettier와 eslint를 같이 사용하기\n\n그렇다면 prettie와 eslint를 동시에 사용하려면 어떻게 설정해야 할까?\n예를 들면 facebook 팀에서 제공하는 eslint-config-react-app(CRA를 사용하면 기본적으로 세팅되어있는 eslint config)을 사용하는 경우 non-style 룰만 포함되어 있기 때문에 별다른 설정 없이 prettier를 같이 사용해도 문제가 안 된다.\n\n그런데 일부 eslint config (e.g. eslint:recommended)를 설치해서 사용하려는데 prettier와 충돌하는 경우 어떻게 해야할까? 여러가지 접근법이 있는데, prettier 실행 후 eslint를 실행하는 방법(prettier-eslint)이 있고, 충돌하는 eslint 규칙을 전부 꺼주는 방법(eslint-config-prettier)도 있다. 앞서 설명했다시피 두 개의 역할을 구분하는 것이 좋으므로 후자의 방법을 추천한다. prettier-eslint의 메인테이너도 2017년에 이미 이 패키지를 사용하지 않는다고 밝혔다.\n\nhttps://twitter.com/kentcdodds/status/913760103118991361\n\n린터 rules인 것 처럼 prettier를 실행하는 플러그인인 eslint-plugin-prettier는 사용하지 말자. 특정 상황에서 유용할 수도 있지만 prettier를 직접 실행하는 것 보다 느리다.\n\n번호를 매겨 정리하자면 다음과 같다.\n\neslint-config-prettier : eslint에서 prettier와 충돌할 수 있는 rule을 꺼버림 ✅\n코드 오류를 잡는데는 eslint, 코드 포맷팅에는 prettier를 사용하는 방법이다.\n\neslint-plugin-prettier : prettier를 eslint의 rules로 동작하게 함\n포맷팅 문제도 오류로 출력되어서 오류 메시지가 지나치게 많아지며 느리다.\n\nprettier-eslint : prettier를 실행하고 나서 eslint --fix를 실행함\nprettier를 단독으로 실행하는 것 보다 훨씬 느리다.\n\nvscode에서 eslint, prettier 사용하기\n\n,  vscode extension을 설치한다.\n\n프로젝트에 eslint와 prettier를 설치한다.\n\nvscode setting에서 prettier를 기본 포맷터로 지정한다.\n\n.prettierrc에 prettier 설정을 작성한다.\n\n.eslintrc에 eslint 설정을 작성한다.\n\n(옵션) prettier 설정과 충돌하는 eslint 설정을 사용하는 경우 (e.g. eslint-config-airbnb)\n\neslint-config-prettier를 설치하고 .eslintrc에 추가한다.\n\n참고\n\nhttps://prettier.io/docs/en/comparison.html\n\nhttps://prettier.io/docs/en/integrating-with-linters.html\n\nhttps://duncanleung.com/profile-measure-find-remove-slow-eslint-rules/\n\nhttps://github.com/prettier/prettier-eslint/issues/101#issuecomment-313233479\n"},{"slug":"2021-03-24-table-of-contents-using-intersection-observer-api","title":"Table Of Contents using Intersection Observer API","body":"Table Of Contents는 목차를 의미하고, 는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다.\n\n구현해야 할 기능과 방법을 생각해보면\n\n글에서 헤더(h1~h6)를 뽑아서 목차 목록을 생성\n\nIntersectionObserver 인스턴스를 생성하고 헤더들을 관찰하도록 함\n\nviewport 내에 보여지는 헤더들 중 가장 상위 헤더를 기준으로 활성화 목차를 결정\n\n목차 아이템 클릭 시 헤더 위치로 이동\n\n목차 아이템은 다음과 같은 인터페이스를 가진다.\n\n헤더들의 offsetTop을 한번만 읽고 끝내기 위해서 목차 정보에 offsetTop을 저장하는데, 이를 오차 없이 사용하려면 저장한 후에 내부에서 height 변동이 없어야 한다. (예를 들면 lazy loading이 되는 이미지가 있다면 Layout Shift가 발생하지 않도록 주의해야 한다)\n\n목차는 딱 하나만 활성화 되어야 하는데, viewport 기준 가장 위의 헤더 또는 해당하는 컨텐츠의 헤더 index가 activeIndex가 된다. 이를 계산하기 위해 IntersectionObserver 인스턴스 내부에서 전달받는 entries 정보를 한번 흩어서 배열(=intersectingList)에 교차 여부를 저장한다. 예를 들면 이 배열에서 intersectingList\\[2]는 현재 3번째 헤더의 viewport 교차 여부를 나타내게 된다.\n\n이후 intersectingList의 item 중 가장 처음으로 true가 되는 인덱스를 찾는다. 이렇게 하면 O(2n)으로 activeIndex를 찾을 수 있다. threshold를 1.0으로 지정하면 요소 전체가 보여야 true로 잡히기 때문에 위에서 찾은 index에서 1을 감하면 activeIndex가 된다. (이렇게 찾는 이유는 n번째 헤더는 보이지 않고 n번째 헤더의 컨텐츠만 보이더라도 activeIndex는 n이어야 하기 때문이다)\n\n이 로직을 훅으로 구현하면 다음과 같다.\n\n이 훅을 사용한 목차를 구현했더니 뭔가 삐걱삐걱..\n\nhttps://codesandbox.io/s/tableofcontents-using-intersection-observer-api-in-react-0jcox\n"},{"slug":"2021-03-25-offsettop-reflow","title":"OffsetTop을 읽으면 reflow가 발생한다?","body":"&#x20;라는 문서를 보는데 Getting box metrics 즉 offsetTop, getBoundingClientRect() 등을 호출하는 api도 적혀 있었다.\n아니 이게 무슨 소리야...내가 reflow를 마구 발생시키고 있었다니...?\n\n그런데 댓글을 보다보니 퍼포먼스탭에서 reflow를 확인할 수 없었다는 얘기도 있어서 실제로 offsetTop을 읽는 테스트 화면을 구현해서 퍼포먼스탭을 보니 reflow가 발생하지 않았다. 음?\n\n이 부분이 궁금해서 여러가지 글들을 읽어봤는데, offsetTop을 읽는 것 자체가 무조건 reflow를 발생시키지는 않는다. 하지만 offsetTop을 읽기 위해서 브라우저가 렌더링 큐에 쌓인 모든 작업을 수행하면서 reflow를 발생시킬 수 있다고 한다.\n브라우저는 최적화를 위해 reflow가 필요한 여러개의 작업을 묶어서 큐에 쌓아서 대기하다가 한번의 reflow로 전부 처리할 수 있도록 하는데, offsetTop 등의 계산된 스타일에 get 요청을 하면 최신값을 읽기 위해 큐를 flush하고 모든 변경사항을 적용한다.\n\n구글 개발자들이 렌더링 퍼포먼스를 개선하는 방법으로 작성한 글 중 도 같은 원리다.\n\n위와 아래 코드의 결과는 동일하지만 성능 차이가 나는 이유이기도 하다. 단순히 box.offsetWidth를 읽는게 문제가 아니고, paragraphs\\[i]의 너비가 변경되면서 스타일이 변경되었기 때문에 box.offsetWidth의 정확한 계산값을 얻기 위해 큐를 flush하고 스타일을 적용해야 하므로 화면을 반복해서 reflow - repaint 하게 된다.\n\n참고\n\nhttps://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\nhttps://www.phpied.com/rendering-repaint-reflowrelayout-restyle/\n\nhttps://developer.chrome.com/docs/devtools/evaluate-performance/\n\nhttps://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=ko\n"},{"slug":"2021-03-26-similar-library","title":"비슷한 라이브러리 비교해보는 글","body":"react vs vue vs angular\n\nvue 허접이 깝치지마라:-)\nhttps://www.npmtrends.com/react-vs-vue-vs-@angular/core\n\nui library\n\n의외로 material-ui가 월등하다. (antd랑 비슷한줄)\n2022.04.12 기준 tailwind의 기세가 엄청나다...물론 mui의 패키지명이 변경된 것도 있지만...\nhttps://www.npmtrends.com/@material-ui/core-vs-antd-vs-react-bootstrap-vs-tailwindcss-vs-@mui/material\n\nglobal state management\n\nredux 화이팅!\nrecoil 히믈내 짝\nhttps://www.npmtrends.com/jotai-vs-mobx-vs-recoil-vs-redux-vs-zustand\n\nremote data fetching\n\nreact-query와 swr은 거~의 비슷한데 react-query가 좀더 앞서나가고 있다.\n2021.09.02 시점에서 react-query가 훨씬 앞서나가고 있다!\nrtk-query는 리덕스 툴킷에 포함되어서 여기서의 비교는 큰 의미는 없어졌다.\nhttps://www.npmtrends.com/react-query-vs-swr-vs-@rtk-incubator/rtk-query\n\ncss-in-js\n\nstyled-components가 훨씬 잘나간다. emotion은 babel 설정이 필요해서 좀 귀찮은듯?\n2021.09.02 linaria 추가\n2022.04.12 @vanilla-extract/css 추가\nhttps://www.npmtrends.com/@emotion/react-vs-linaria-vs-styled-components-vs-@vanilla-extract/css\n\nanimation for react\n\n후발주자 framer-motion의 기세가 만만치않다.\n2022.04.12 기준 이미 framer-motion이 짱먹었다. 짱짱맨.\nhttps://www.npmtrends.com/react-spring-vs-react-motion-vs-framer-motion-vs-react-pose\n\ninput masking\n\n다운수는 비슷비슷한데 stars는 cleave.js가 제일 많다.\nhttps://www.npmtrends.com/text-mask-core-vs-cleave.js-vs-imask-vs-inputmask\n\n생각날때마다 업뎃 예정\n"},{"slug":"2021-04-10-react-query-staletime-cachetime","title":"React Query에서 staleTime과 cacheTime의 차이","body":"React Query의 라이프 사이클\n\nA 쿼리 인스턴스가 mount 됨\n\n네트워크에서 데이터 fetch 하고 A라는 query key로 캐싱함\n\n이 데이터는 fresh 상태에서 staleTime(기본값 0) 이후 stale 상태로 변경됨\n\nA 쿼리 인스턴스가 unmount 됨\n\n캐시는 cacheTime(기본값 5min) 만큼 유지되다가 가비지 콜렉터로 수집됨\n\nv4부터는 기본값이 Infinity로 변경될 예정이라고 함\n\n만일 cacheTime이 지나기 전에 A 쿼리 인스턴스가 새롭게 mount되면, fetch가 실행되고 fresh한 값을 가져오는 동안 캐시 데이터를 보여줌\n\nstaleTime\n\n데이터가 fresh -> stale 상태로 변경되는데 걸리는 시간\n\nfresh 상태일때는 쿼리 인스턴스가 새롭게 mount 되어도 네트워크 fetch가 일어나지 않는다.\n\n데이터가 한번 fetch 되고 나서 staleTime이 지나지 않았다면 unmount 후 mount 되어도 fetch가 일어나지 않는다.\n\ncacheTime\n\n데이터가 inactive 상태일 때 캐싱된 상태로 남아있는 시간\n\n쿼리 인스턴스가 unmount 되면 데이터는 inactive 상태로 변경되며, 캐시는 cacheTime만큼 유지된다.\n\ncacheTime이 지나면 가비지 콜렉터로 수집된다.\n\ncacheTime이 지나기 전에 쿼리 인스턴스가 다시 mount 되면, 데이터를 fetch하는 동안 캐시 데이터를 보여준다.\n\ncacheTime은 staleTime과 관계없이, 무조건 inactive 된 시점을 기준으로 캐시 데이터 삭제를 결정한다.\n\n그 외\n\nisLoading : 캐싱된 데이터가 없을때 fetch 중에 true\n\nisFetching : 데이터가 fetch될 때 true, 캐싱 데이터가 있어서 백그라운드에서 fetch되더라도 true\n"},{"slug":"2021-04-16-useimperativehandle-forwardedref","title":"useImperativeHandle & forwardedRef 활용하기","body":"useImperativeHandle와 forwardedRef를 활용하면 부모 컴포넌트가 자식 컴포넌트의 함수를 호출하거나 값을 가져올 수 있다.\n"},{"slug":"2021-05-26-webpack-vite","title":"Webpack 보다 더 빠른 빌드툴, Vite","body":"이런 제목을 어디서 본 것 같은데?\n라고 생각한다면 정상이다.\n\n\nWebpack 보다 더 빠른 빌드툴, Snowpack\n\nVite는 Snowpack과 아주 유사한 컨셉의 프론트엔드 빌드툴이다.\nVue.js의 창시자로 유명한 Evan You가 개발했고 이름값을 하는 것 같다. SvelteKit도 Snowpack을 손절하고 Vite로 갈아탄 듯 하다 (웃픈...)\n\nSvelteKit에서 설명하는 Vite의 비교장점은 Snowpack보다 SSR을 더 잘 지원한다는 부분이었고, 내가 느낀 장점은 Snowpack은 chrome devtools에 tsc와 esbuild로 이미 빌드가 된 상태의 js 파일을 보여줘서 source탭을 무용지물로 만드는 반면 Vite는 소스맵을 잘 지원한다는 점이다. 가장 큰 차이점은 최종 빌드를 rollup으로만 제공하기 때문에 통합된 개발환경을 제공한다는 점이다.\n\n웹팩에 추가 설정을 붙이려면 craco같은 라이브러리로 조작해야하는 확장성 제로 CRA에 비해 자체적으로 config를 수정할 수 있도록 지원하나, jest 세팅이나 svg to component 등을 하나하나 스스로 해야한다는 단점도 존재한다.\n\n다만 그렇기 때문에 함께 설치되는 라이브러리 수도 적고 설치부터 실행까지 걸리는 시간도 굉장히 적게 소요된다. 나 에서도 Vite를 지원하고 있기 때문에 react-router처럼 예제를 Vite로 구현한 라이브러리도 많아지고 있다.\n그러니까 사이드 프로젝트에는 Vite 쓰자.\nhttps://vitejs.dev/\n"},{"slug":"2021-08-09-scroll-event-raf-throttle","title":"scroll event에 rAF throttle을 적용해야할까","body":"프론트엔드 개발할때 가장 많이 사용하는 최적화 방법 중 하나가 쓰로틀링 / 디바운싱이다. throttle과 debounce는 자주 실행되는 함수들의 실행빈도를 줄여서 성능을 개선할 수 있다. throttle의 경우 함수 실행을 지연시켜서 실행 횟수를 줄이면서 지정한 시간동안 한번의 실행을 보장하고, debounce는 여러번 발생하는 이벤트를 단일 이벤트로 묶는다는 차이가 있다. 예를 들면 스크롤 이벤트에 throttle을 적용하는 경우 이벤트가 일정시간마다 발생하고, debounce를 적용하는 경우 스크롤 이벤트가 끝난 후 (또는 시작 직후)에만 발생하게 된다.\n\n쓰로틀링과 디바운싱은 lodash 라이브러리에서 제공하는 함수로 쉽게 적용할 수 있다. lodash에서 제공하는 throttle함수는 아무런 옵션(시간값)을 주지 않으면 기본적으로 requestAnimationFrame 기반으로 동작한다. 즉, raf-schd같은 라이브러리를 추가로 설치하지 않아도 rAF 기반 쓰로틀링을 사용할 수 있다.\n\n그동안 브라우저 렌더링 성능을 위해 스크롤 이벤트에 무조건 rAF 기반 쓰로틀을 적용했었는데 뭔가 미심쩍은 부분이 있어 테스트와 구글링을 해보니 다음과 같은 사실을 알게 되었다.\n\n스크롤 이벤트는 브라우저가 스크롤 위치 변경을 렌더링 할때마다 트리거 되는 것이여서 자체적으로 rAF가 제공해주는것과 동일한 결과를 갖는다.\n\n즉, 아래와 같이 rAF 쓰로틀을 적용한 코드와 적용하지 않은 코드가 성능상 동일하다는 것이다.\n\n스크롤 이벤트에서 rAF를 사용하면 좋은 경우\n\n그럼 앞으로 스크롤 이벤트에는 무조건 throttle을 할 필요가 없을까? 여기에서는 강제 동기식 레이아웃, 레이아웃 스래싱이라는 개념을 짚고 넘어갈 수 있다. 브라우저는 최적화를 위해 reflow(=layout)가 필요한 여러개의 작업을 묶어서 큐에 쌓고 대기하다가 한번의 reflow로 전부 처리할 수 있도록 하는데, 기하학적인 값을 요청하면 이러한 최적화 작업을 무시하고 즉시 레이아웃을 reflow 한다.\n\n어떤 박스의 높이를 기록하는 코드이다. 이때 box.offsetHeight는 브라우저에서 이전 프레임의 레이아웃값을 반환한다.\n\n이런 코드를 실행하는 경우, 브라우저는 먼저 높이 변경을 실행한 후에 레이아웃을 실행해야 box.offsetHeight에서 정확한 값을 반환할 수 있다. offsetHeight이라는 호출 자체는 레이아웃을 무조건 발생시키는 조건은 아니지만 선행조건에 따라 강제 동기식 레이아웃을 발생시키는 것이다.\n\n이러한 현상을 피하기 위해서는 읽는 것은 마지막 프레임의 값으로 하도록 하고, 스타일은 나중에 적용하도록 실행 순서에 유의해야 한다.\n\nwindow.requestAnimationFrame(callback)은 브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 callback을 실행해서 해당 애니메이션을 업데이트 하도록 한다. 즉, 기하학적 값이나 스크롤 stuff를 읽는 작업을 현재 프레임에서 실행하고, requestAnimationFrame의 콜백으로 쓰기 / 수정 로직을 넘기면 다음 프레임에서 함께 실행하도록 예약이 가능하다. 이로써 단일 렌더링 프레임 내에서 여러 업데이트를 수행할 위험을 방지할 수 있다. 이를 간단한 쓰로틀링과 함께 적용하면 아래와 같다.\n\n다만 앞서 언급했듯이 scroll event 자체가 rAF 쓰로틀링이 적용된 상태이므로 ticking: true는 절대 콘솔에 나타나지 않는다. 따라서 위 코드는 최종적으로 아래와 같이 정리할 수 있다.\n\n물론 이정도의 가벼운 작업은 실제로 크롬 데브툴의 퍼포먼스탭에서 비교해보면 어떤 방식으로 구현하더라도 거의 차이가 나지 않는다. (심지어 cpu 쓰로틀링을 걸더라도) changeBoxWidth에 해당하는 작업이 무거운 reflow / repaint 작업일때 유의미한 결과를 얻을 수 있을 것이다. 코드 작성 후에 퍼포먼스 탭에서 실제 성능 데이터를 확인하는것이 도움이 된다.\n\nhttps://codesandbox.io/s/throttle-test-3sdgv\n\n참고\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Document/scroll\\_event\n\nhttps://www.html5rocks.com/en/tutorials/speed/scrolling/\n\nhttps://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing\n\nhttps://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\nhttps://johnresig.com/blog/learning-from-twitter/\n"},{"slug":"2021-08-15-testing-library","title":"testing-library 사용팁","body":"리액트로 개발하다보면 테스트는 거의 jest + testing-library 조합을 깔고 가는 듯 하다. CRA도 이 조합으로 기본적으로 세팅되어서 나온다. 가장 최근  테스팅 툴 부문에서도 testing-library가 만족도 랭킹 1위를 기록했다.\n\ntesting-library는 리액트에 국한된 테스팅 툴은 아니고, DOM Testing Library라는 코어 패키지가 존재하고 뷰나 앵귤러 등 여러 프레임워크에 적용할 수 있도록 별도 패키지로 제공되고 있다.\n\n테스트 속도 vs 신뢰도\n\nhttps://twitter.com/kentcdodds/status/1349211410442579968\n\n먼저 짚고 넘어가고 싶은 부분이다. 물론 테스트코드를 잘못 짜서 느리게 실행된다면 문제가 될 수 있다. (불필요한 쿼리 실행 등) 하지만 정상적인 테스트코드가 단지 느리다는 이유로 쿼리를 바꿔야만 할까?\n\ntesting-library의 쿼리 우선순위와 쿼리 성능 비교\n\ntesting-library의 와 쿼리 성능 때문에 가끔 고민이 될 때가 있다.\ntesting-library는 유저 인터랙트와 가장 유사하게 테스트를 짜는 것을 권장한다.\n\n이렇게 생긴 버튼이 있다고 치면, 화면을 보는 사용자는 이 버튼의 className이 submit-button인지 data-testid가 submit-button-testid 인지 알고 누르는게 아니다. 그냥 등록 이라고 적힌 버튼이라 누르는거다.\n\n각각의 테스트에 대한 쿼리를 적어보면 아래와 같다.\n\n쿼리 우선순위는 당연히 getByRole이 가장 높다. 그렇다면 뭐가 문제인가 하면 쿼리 속도 차이가 엄청나게 크다는 것이다. 이 버튼 하나만 만들어서 codesandbox에서 테스트를 돌려보니 각각 2ms, 2ms, 11ms를 기록했다. 화면이 복잡할수록, 테스트가 많을 수록 이 차이는 엄청난 차이를 만들어낼것이다.\n\ntesting-library 레포에서도 getByRole의 성능 문제는 단골 이슈다.\nhttps://github.com/testing-library/dom-testing-library/issues/820\nhttps://github.com/testing-library/dom-testing-library/issues/552\n\n쿼리 우선순위를 우선시 해야하는 이유\n\n그냥 빠른 getByTestId를 쓰면 안되나? 라고 할 수 있는데 여기에는 맹점이 있다. 예를 들면 나는 사용자에게 등록이라는 버튼을 제공하려고 했는데 실수로 등럭이라고 작성할 수도 있다. 그런데 data-testid를 사용하는 쿼리 셀렉팅에는 전혀 문제가 발생하지 않는다.\n\n이건 다른 얘긴데 className 유무로 스타일을 테스트 하는 것도 문제점이 존재한다. 예를 들면 노란색 버튼을 클릭하면 active라는 className이 붙고 빨간색 버튼으로 바뀌는 토글 버튼이 있다고 가정하자.\n\n이 테스트 자체는 아무런 문제도 없다. 그런데 만약 scss에서 background를 yellow에서 blue로 변경한다면? 그래도 정상동작하는게 문제다. 이 점에서 css-in-js로 스타일을 주입하고 테스트하는게 더 정확하긴 하다. (물론 이건 예시고 컬러값, 픽셀값까지 테스트하는건 좀 아닌 듯함)\n\n쿼리 우선순위에 대해 말하다보니 빙 돌아왔는데, 요점은 사용자 관점에서 테스트를 작성하자는 것이다.\n\n쿼리 우선순위를 지키면서 신뢰도 높은 테스트코드를 작성하는 방법\n\nhtml(jsx)을 잘 작성한다\nhtml이 프로그래밍 언어가 아니라는 유머에 웃을때가 아님👻👻\n\n에서 테스트 쿼리에 익숙해지자\n\n도 있다\n\nreact-testing-library 사용시 자주하는 실수\n\n원문\nhttps://kentcdodds.com/blog/common-mistakes-with-react-testing-library\n\n몇가지 핵심이라고 생각하는 부분만 가져오고 사견을 붙였는데, 원문을 읽는 것을 추천한다.\n\n가정문 올바르게 쓰기\n\njest-dom이 제공하는 들을 활용하는 것을 강추한다. 결과 자체는 동일하지만 실패할 경우 오류 메시지가 다르다.\n\n불필요한 act 사용 🙅‍♀️\n\n개발자들이 act warning 메시지를 볼 때마다 이런 식으로 act로 감싸려고 하는데 render나 fireEvent는 이미 act로 래핑된 함수라 무의미한 행동이다. 워닝 메시지가 발생한다면 테스트가 종료된 후 상태 변경이 일어난 것 이므로 이에 대한 코드 수정이 필요하다.\n\n쿼리를 올바르게 쓰기\n\n\\*ByRole를 더 활용하기\n\n위와 같은 형태의 버튼도 쿼리가 가능하다는 장점이 있다.\n\n접근성 role를 불필요하게 등록하지 않기\n\nbutton은 button이라는 role을 가진 요소이므로 등록이 불필요하다. 이와 같이 테스트를 한답시고 함부로 role을 명명하고 등록하면 안된다. 우선 에 대한 충분한 학습이 필요하다.\n\nwaitFor 내에서 사이드 이펙트 수행하지 말기\n\nwaitFor는 수행한 작업으로 인해 가정문이 통과되는 사이에 시간이 걸리는 항목을 위한 것인데, 콜백은 몇번이고 실행될 수 있기 때문에 내부에 side-effect를 작성하면 안된다.\n\n참고\n\nhttps://kentcdodds.com/blog/common-mistakes-with-react-testing-library\n\nhttps://testing-library.com/docs/queries/about#priority\n"},{"slug":"2021-08-21-context-api-redux","title":"Context API가 존재하지만 여전히 사람들이 redux와 전역 상태관리 라이브러리를 쓰는 이유","body":"전역(global) 상태관리\n\n옛날옛적 호랑이 담배피던시절(?) 리액트의 러닝커브를 올리는 주범은 redux라고 해도 과언이 아닐 정도로 리덕스는 리액트를 개발하려면 react-router-dom과 함께 필수로 배워야 하는 서드파티 라이브러리였으며 보일러 플레이트 코드도 엄청난 양을 자랑했던 그런 라이브러리였다. (reducer, action, ...)\n\n\n\n일반적으로 리액트 데이터는 부모로부터 자식으로 props를 통해 탑-다운으로 전달되는데, 이 단계가 너무 많아진다거나 전달을 여러곳에 해줘야하는 경우에 전역 스토어에 데이터를 저장하고 이를 데이터가 필요한 컴포넌트에 따로 공유할 수 있다.\n어떤 데이터를 전역/로컬에 저장할 것인지는 개발자가 선택해야한다. 몇단계만 전달하면 되거나 굳이 전역으로 관리할 필요 없는 데이터를 전역 스토어에 넣는 것은 코드의 관리 측면에서도 좋지 않다.\n\ncontext api\n\n리액트 16.3부터 도입된 context api를 사용하면 네이티브 리액트만으로 전역 상태관리가 가능하다. 거의 모든 상태관리 라이브러리들은 이 api를 기반으로 개발되어있다.\n\nReact.createContext 메서드를 통해서 컨텍스트를 만들면 Provider와 Consumer가 제공된다. 위의 코드는 useState가 반환하는 값을 Provider에 제공한 형태다.\n\n위와 같이 위에서 만든 Provider로 감싸주면, \\<Modal />은 Provider에 저장된 값을 사용할 수 있다.\n\n리액트와 하위 컴포넌트 리렌더링\n\n이런 식으로 개발하는 이유는 리액트의 렌더링 특성 때문이다. 기본적으로 리액트는 상위 컴포넌트에서 state가 변하면 하위 컴포넌트를 전부 렌더링한다.\n\n위와 같은 코드가 있다고 하자. 버튼을 누르면 show라는 App 내의 state 값이 변경된다. \\<Child />는 show라는 props를 쓰지 않지만, 하위 컴포넌트이기때문에 렌더링이 된다. 이를 방지하기 위해서 아래와 같은 방법을 사용할 수도 있다.\n\nReact.memo의 두번째 인자로 아무것도 반환하지 않는다면 자체적으로 props를 비교해서 렌더링 여부를 결정하고, 렌더링 여부 기준을 직접 작성할 수도 있다. 하지만 그렇다고 해서 memo를 무분별하게 남발하는건 좋지 않다. 현재 리렌더링을 memo 하려는 컴포넌트에서 비교 연산과 리렌더링 중 어느 쪽이 퍼포먼스 최적화에 더 적합한지 확인이 필요하기 때문이다.\n\n비교적 간단한 해결방법은 위와 같이 children을 활용하는 것이다. 위의 코드에서 children은 리렌더링이 되지 않는다.\n\n마찬가지로 ModalProvider 내부에서 show가 변경되더라도 children인 \\<Modal />과 \\<ModalToggleButton />에는 영향을 주지 않는다. 리액트에서는 useContext라는 훅을 제공해주는데 이 훅에 컨텍스트를 주입하면 아무 컴포넌트에서 컨텍스트 프로바이더에 저장된 값을 사용할 수 있다.\n\ncontext api의 문제\n\n그런데 이 코드에 심각(?)한 문제가 있다. 버튼을 클릭하면 \\<Modal />만 렌더링 되는 것이 아니라 \\<ModalToggleButton />도 같이 렌더링이 되는 것이다. Context.Provider는 value로 저장된 값이 변경되면 useContext(Context)를 사용하는 컴포넌트도 같이 렌더링을 한다. 그렇기 때문에 show라는 상태를 사용하지 않는 \\<ModalToggleButton />도 같이 렌더링이 된다.\n\n이를 해결하려면 아래와 같이 코드를 작성해야 한다.\n\n컨텍스트를 상태값 / 액션으로 나누어서 위에서 언급한 리렌더링 문제는 발생하지 않는다. 그런데 딱 봐도 코드가 좀 지저분하고 보일러플레이트 코드가 너무 많다. 거기다 지금은 간단한 boolean값이었지만, 만약 복잡한 state라면 어떨까? object에서 상태가 부분적으로 변경이 되더라도 컨텍스트를 사용하는 모든 컴포넌트가 리렌더링 될 것이다. 그리고 컨텍스트를 추가할 때마다 프로바이더로 매번 감싸줘야하기 때문에 Provider hell을 야기할 수 있다.\n\n이렇기 때문에 context api는 글로벌 상태관리 라이브러리를 대체할 수 없고, 여전히 많은 리액트 개발자들이 redux, mobx 등을 사용하고 있는 것이다.\n\n전역 상태관리 라이브러리 소개\n\n유명하거나 알아두면 좋은 라이브러리 위주로 간단하게 짚어보려고 한다.\n\nredux\n\n한때는 리액트를 어렵게 만드는 주범이었지만 hook 도입과  등장 이후로 사용이 정말 간편해졌다. 나도 mobx로 잠깐 도피했었다가 mobx는 hook 지원을 빠릿하게 대응하지 않았고 redux팀은 hook 전환에 빠르게 대응했기 때문에 다시 redux로 갈아탔다.\n\nmobx\n\n리덕스가 휘황찬란한 보일러플레이트를 남발하던 시절 mobx는 class로 store를 정의하고 스토어를 하나로 관리한다는 느낌이 있어서 상당히 편리했다. 그러나 hook 대응이 다소 미적지근했고, class와 데코레이션을 사용하는 것 자체가 진입장벽이 될 수도 있을 것 같다. 예전에는 백엔드에서 프론트엔드로 전향하는 개발자들이 스프링의 어노테이션과 비슷한 데코레이터를 보고 친숙함을 느낄 수도 있었겠지만 요즘은 프론트엔드부터 배우는 학생들이 많으니 말이다. (물론 mobx에 다른 스토어 선언 방법도 존재하는데, 이런 다양함이 mobx를 더 어렵게 만든다) redux-toolkit으로 인해 사용방법이 정돈이 된 리덕스와 달리 mobx는 다양한 사용법을 제시하다보니 이 점이 혼란을 일으키는 것 같다. 개인적으로는 더이상 추천하지 않음!\n\nrecoil\n\n페이스북에서 공식적으로 개발하고 있는 전역 상태관리 라이브러리다. 아직 알파버전이지만 프로덕션에 도입한 곳도 꽤 있는 듯 하다. 스토어 선언이 상당히 간편하고 간결하다. context advanced 같은 느낌으로, 위에서 언급한 context api의 문제점을 겪지 않아도 되며 리덕스로 따지면 selector 같은 기능도 제공한다. 리덕스가 툴킷이 생기면서 많이 간소화 되었다고는 하나 거의 useState 쓰는 느낌인 recoil에 비할바는 못된다. 개인적으로 사이드 프로젝트에서 활용하고 있고, 신규 프로젝트에는 recoil을 도입하고 있다.\n\njotai\n\n조타이는 위 3개보단 덜 유명한 라이브러리긴 하지만 이번에 서비스 개발할때 도움을 받은지라 소개해본다. 사용법이나 컨셉 자체는 recoil과 거의 유사하며, react-spring을 개발한 팀에서 만든 오픈소스 라이브러리다. recoil과의 비교는 공식 문서를 참고하면 좋을 것 같은데 아무래도 key를 선언하는 recoil보다는 객체의 아이덴티티에 의존하기 때문에 간단한 데이터를 다루는 정도일때 사용하는 것이 좋다고 한다.\n직접 사용해봤을때의 장점은 Provider가 optional이라는 점이고, 용량이 gzip 2kB로 매우 가벼운 라이브러리라는 것이다. (recoil은 20kB) 단점은 react-refresh 대응 문제가 있다. (개발중인 코드를 수정하면 앱의 state가 날아간다)\n때문에 이미 redux나 mobx를 사용중인 프로젝트에서 렌더링 최적화를 위해 작은 데이터를 컨텍스트로 다루고 싶을때 대용으로 사용하기 좋을 것 같다.\n"},{"slug":"2021-08-21-react-query-redux","title":"react-query가 redux같은 전역 상태관리 라이브러리를 대체할 수 있을까","body":"react-query는 서버 상태를 다루는 라이브러리다.\n\nredux, mobx 등은 클라이언트 상태를 다루는 라이브러리다.\n\n즉, react-query는 전역 상태관리 라이브러리가 아니라 서버와 클라이언트 간의 비동기 작업을 쉽게 해주는 라이브러리다. 다만 react-query를 도입한다면 개발자가 전역적으로 관리해야하는 데이터는 매우 적을 것이다. 때문에 recoil이나 jotai같은 간소한 상태관리 라이브러리를 함께 사용하는 것도 좋은 방법이다.\n\n예를 들면 과거 리액트 개발자들은 서버에서 데이터를 받아오는 작업을 리덕스에서 처리하기 위해 redux-thunk, redux-saga 등을 이용해서 비동기 작업을 수행하고 데이터를 리덕스 스토어에 저장한 뒤 그 데이터를 각 컴포넌트에서 사용했다.\nreact-query는 이 작업을 매우 간편하게 만들어주는데다가 데이터 캐싱을 아주 쉽게 해결할 수 있다. 쿼리에 staleTime: Infinity, cacheTime: Infinity 옵션만 추가하면 앱을 끄기 전까지 다시 fetch되지 않는 데이터로 만들 수 있다. 데이터가 처음 fetch되는 동안 isLoading 등의 상태를 직접 선언하고 조작할 필요도 없다. react-query에서 모든 상태값과 메서드를 제공하기 때문이다.\n\n물론 이러한 서버 데이터와 관계없이 전역적으로 다뤄야 하는 데이터들이 있다. 예를 들면 theme: 'light' | 'dark'를 저장하고 있는 전역 데이터는 클라이언트에서만 다루는 데이터다. 이러한 데이터는 react-query에 임의로 저장하고 다루는 것이 아니라 컨텍스트나 전역 상태관리 라이브러리를 사용해서 핸들링 해야 한다.\n\n현재 가장 추천하는 조합은 react-query + recoil 이다. context api가 가지고 있는 여러가지 이슈가 있기 때문에 전역 상태관리 라이브러리 하나는 사용을 해야 개발이 편한데, 성능 이슈 없이 간단하게 사용할 수 있기 때문에 recoil을 추천한다.\n\n참고\n\nhttps://react-query.tanstack.com/guides/does-this-replace-client-state\n"},{"slug":"2021-08-26-usememo","title":"간단한 연산에 useMemo 쓰지 말자","body":"공식 설명에도 computeExpensiveValue라고 설명하고 있다. 즉 비싼 연산을 언급하는 것이다. 예를 들면 데이터 만개를 변경한다던가...\n\na === b는 전혀 비싼 연산이 아니다! 이 경우, 메모하는 메모리 비용에다가 \\[a, b]로 들어간 디펜던시에서 리액트의 디펜던시 비교연산인 objectis를 수행하는 연산이 훨씬 더 비용이 많이 들 것이다.\n\n훅 디펜던시는 자바스크립트 원시값(Primitive)을 비교하기 때문에 useMemo로 메모이제이션을 하지 않아도 영향을 주지 않는다. (isSame, isEqual이 object, array가 아니기 때문임을 주의!)\n\n그렇다면 비싼 연산인지 아닌지는 어떻게 판단할 수 있을까? 이는 해당 컴포넌트의 렌더링이 자주 일어나는지, 연산이 복잡한지에 따라 달라지기 때문에 확답할 수 없다. 개발자도구를 적극적으로 활용하자.\n\n참고\n\nhttps://kentcdodds.com/blog/usememo-and-usecallback\n\nhttps://github.com/facebook/react/blob/main/packages/shared/objectIs.js\n\nhttps://developer.mozilla.org/ko/docs/Glossary/Primitive\n"},{"slug":"2021-08-28-typescript-4.4","title":"TypeScript 4.4에 추가된 기능","body":"정말 좋은 기능들이 추가되어서 정리해본다.\n\nalias 된 조건문과 판별문의 제어 흐름 분석\n\n위의 케이스는 기존 타입스크립트에서도 정상적으로 인식했다. 그런데\n\n이렇게 typeof arg === \"string\"을 alias 하는 경우 인식을 못했었다.\n그런데 타입스크립트 4.4에서는 자동으로 인식한다.\n\n원래 아래와 같은 케이스를 해결하려면 타입가드 함수를 따로 선언해야했는데 이제는 자동으로 인식한다!\n\n인덱스 서명에 Symbol과 Template String 패턴을 사용할 수 있음\n\n인덱스 서명이 뭐냐면\n\n이런것이다. Array의 index는 number만 될 수 있다. 타입스크립트는 이제까지 인덱스 서명이 될 수 있는 값을 string과 number로 제한했는데 이제 Symbol과 Template String이 추가되었다.\n\n이렇게 사용이 가능하다는 것이다.\n\nstrict 옵션이 켜졌을 때 trycatch의 err의 기본 타입이 unknown\n\nuseUnknownInCatchVariables: boolean 옵션으로 조절할 수 있다.\n\nExact Optional Property Types\n\n옵셔널한 프로퍼티의 경우 undefined로 인식을 하는데 이것이 undefined라는 값을 갖는 것인지 아니면 값이 존재하지 않는 것인지 (delete keyName) 를 명확히 해주는 옵션이 추가되었다.\n\nClass에서 static 블록 지원\n\ninlay hint 지원\n\n\n\nvscode에서도 인텔리제이처럼 inlay hint를 사용할 수 있다.\nvscode의 settings.json에 다음과 같이 세팅한다.\n\n\\~~현재 vscode의 내장 ts 버전은 4.3.5기 때문에 4.4+를 사용하려면 패키지를 워크스페이스에 설치하고 해당 경로를 지정해야 - typescript.tsdk - 한다. 글로벌에 설치하고 지정해도 무방하지만, 워크스페이스에 귀속되는 것이 안전하다.~~\n2021.09.03 이후 vscode의 내장 ts가 4.4로 업데이트 되어서 inlay hint를 그냥 사용할 수 있다.\ninlay hint 컬러 커스텀 값을 지원하는 테마가 많지 않기 때문에 직접 지정해야 할 확률이 높다. editorInlayHint.foreground와 editorInlayHint.background는 이를 위한 설정값이다.\n\n자동 import가 목록에서 실제 경로를 보여줌\n\n\n원래는 이렇게 보여줬는데\n\n\n이렇게 보여주게 되었다. 자동 import 목록 박스의 width의 한계가 있기 때문에 어떤 패키지인지 보기 편해졌다.\n\n참고\n\nhttps://devblogs.microsoft.com/typescript/announcing-typescript-4-4/\n"},{"slug":"2021-08-29-redux-saga","title":"redux-saga를 추천하지 않는 이유","body":"redux-saga의 단점\n\n생소한 generator 함수\n\nES6의 generator & yield는 비동기처리를 위한 문법인데 솔직히 프론트엔드 직무가 떡상한 시점에서 비동기 코드를 동기 코드처럼 사용할 수 있게 해주는 ES7 async / await 가 등장했기 때문에 다소 생소한 문법이다. redux-saga는 이 generator 함수를 기반으로 하고 있어서 이에 대한 지식이 없으면 러닝 커브가 굉장히 높다. 이미 async / await 라는 훌륭한 비동기처리 문법이 존재하고 redux-saga 외에는 generator를 사용하는 네임드 서드파티 라이브러리가 전무한 시점에서 매우 아쉬운 부분이다. (그나마 생각나는게 mobx-state-tree?)\n\ntypescript 지원이 미흡함\n\nredux-saga/effects의 타입스크립트 지원은 매우 아쉬운 수준이다.\n\n자동 타입 유추로 user가 User타입이기를 기대하지만 any가 나온다. call의 제네럴에 User를 직접 대입하거나, user에 결과값이 User라고 직접 작성해야만 한다.\n이를 해결하기 위해 typed-redux-saga라는 또다른 래퍼 라이브러리를 설치하면 해결되긴 한다. 그런데 redux-saga도 redux의 서드파티 라이브러리인 시점에서 redux-saga의 서드파티 라이브러리를 또 설치한다...? 관리가 어떻게 될지는 알 수 없는 일이다.\n\n가장 최근 릴리즈가 2019년임\n\n아무리 훌륭한 라이브러리여도 2019년이 마지막 릴리즈인것은 이미 메인테이너가 손을 뗀 것이다. 특히 타입스크립트의 개발이 꾸준히 일어나고 있는데 개선점이 1도 없을 수는 없다. 당장 redux-saga의 깃헙 이슈란에 쌓인 이슈만 200개가 넘는다.\n물론 하단에서 설명할 redux-thunk의 업데이트 역시 3년전이나 (), 이는 redux팀에서 직접 관리하는 라이브러리이며 이슈도 5개밖에 없다. 지속적으로 개발되고 있는 @reduxjs/toolkit에서도 이 버전을 사용하고 있으므로, 이슈가 없기 때문에 업데이트를 하지 않는 것으로 보인다.\n\n2022.03.15 기준 redux-saga의 issue는 38개로 많이 감소한 상태이나, release 버전은 2019년에서 멈춰있다. redux-thunk는 2021년 11월에 업데이트가 되었다.\n\nredux-toolkit은 redux-thunk를 기반으로 함\n\n예전에는 redux의 사용방법도 불편했고 redux-thunk의 활용방법도 모호했기 때문에 redux-saga가 많이 쓰였다. 하지만 이제 redux-toolkit이 등장했고 아주 편하게 redux와 비동기처리가 가능하게 되었다. redux-toolkit에서는 비동기 처리를 위한 미들웨어 세팅을 기본값으로 redux-thunk로 해놓았고 문서에도 이를 기반으로 설명하고 있다. redux-thunk 대신 redux-saga를 사용하려면 다른 예제들을 찾아 헤매면서 직접 설정하고, 오류가 발생해도 어렵사리 해결해야 한다.\n\n대안\n\nredux를 사용할때 가능한 redux-toolkit을 사용하고 비동기 처리가 필요하다면 툴킷에 내장된 redux-thunk를 사용하자.\n그런데 만약 서버 데이터를 비동기로 받아오기 위해 redux와 비동기 미들웨어가 필요한 상황이라면 이를 redux로 해결한다는 생각을 고심해 볼 필요가 있다. 물론 redux는 아주 훌륭한 클라이언트 사이드 전역 상태 관리 라이브러리지만 서버 데이터 처리나 비동기 처리 만을 위해 고안된 라이브러리는 아니다.\n서버 state를 관리하기 위한 라이브러리인 react-query나 swr을 도입하면 어떨까? 물론 라이브러리를 많이 설치하면 그에 대한 사이드 이펙트는 분명 존재한다. 하지만 우리가 서버에서 받아오는 데이터를 무조건 redux에 저장할 필요가 없고, isLoading나 error나 데이터 캐싱 등 서버 상태를 다루기 위해 매번 서버 상태와 관련된 프로퍼티를 redux store에 추가하던 비용을 생각하면 서버 상태 관리는 클라이언트 전역 상태 관리와 분리할 필요가 있다고 본다.\n사실 서버 상태를 분리하고 나면 redux를 사용할 일이 매우 줄어들 것이다. recoil이나 jotai같이 context api 처럼 사용할 수 있는 가벼운 전역 상태 관리 라이브러리 도입이 더 맞을 수도 있다.\n\n추가 잡담 (updated 22.03.15)\n\n이 글 조회수가 너무 많아서 쓰는 글...ㅠㅠ (쫄려서 쓰는 글 아님👀) 물론 redux-saga는 star 22k에 달하는 훌륭한 라이브러리이고 감히 나같은 무지렁쟁이가 품평할건 아니고, 본문은 어디까지나 사견이니 참고로만 생각하는게 좋을 듯 하다. 그냥 rq와 saga를 프로젝트에서 섞어 쓰는 과도기를 겪다보니 작성하게 된 글로, saga에게는 saga만의 장점이 있다. 로직 단위의 테스트코드 작성이 간편한 부분이나, 트랜잭션 처리가 쉬운 부분 등등...\n"},{"slug":"2021-09-02-eslint","title":"ESLint 알고 쓰기","body":"ESLint란? javascript 코드에서 문제를 찾아주고 (find) 고쳐주는 (fix) 정적 코드 분석 도구다. create-react-app으로 리액트 앱을 런칭하면 기본적으로 eslint-config-react-app이라는 eslint 설정이 세팅되어 있다. 아무래도 리액트에 입문할때 대부분 CRA로 앱을 만들고 설정을 건드리지 않기 때문에 직접 eslint를 설정해야 하는 상황이 오면 당황하게 된다. 대체 plugin은 뭐고 config는 뭐고 extends는 뭐고 rule은 뭐고 recommended는 뭐고 airbnb는 뭐란 말인가?\n\neslint-plugin|config-\\*\n\n우선 패키지에 대해 알아보자. eslint-plugin-import, eslint-plugin-react, eslint-config-airbnb, eslint-config-prettier 이 4가지 패키지의 차이점은 앞 2개는 eslint-plugin-\\*이고 뒤 2개는 eslint-config-\\*라는 점이다.\n\neslint-plugin-\\*\n\nplugin은 룰을 정의한 것으로, 예를 들면 eslint-plugin-react는 리액트와 관련된 룰을 정의한 패키지이다.\n\n그러니까 이렇게 넣어도 아무런 동작도 안한다. 그냥 이제 eslint-plugin-react에 존재하는 룰을 사용할 수 있게 된 것이다. 만약 룰을 사용하고 싶다면 아래와 같이 정의해야 한다.\n\n하지만 이런식으로 매번 모든 룰에 대해 분석하고 파악해서 일일히 작성하기엔 너무 귀찮은 일이다. 때문에 대부분의 플러그인은 recommended나 strict, all 등의 자체 설정을 제공하는 것이다.\neslint-plugin-react의 경우 recommended와 all 두가지의 config를 제공하는데 다음과 같이 사용할 수 있다.\n\nplugins가 있어야 eslint-plugin-react의 룰들을 쓸 수 있다면서 왜 extends만 썼냐고 할 수 있는데, 이건 를 까보면 알 수 있다.\n\n\n\n이 설정이 이미 plugin 선언을 포함하고 있기 때문에 따로 eslint에 적지 않아도 되는 것이다. 대부분의 recommended config가 이러한 형태를 취하고 있다.\n\neslint-config-\\*\n\n이러한 eslint-plugin-\\* 패키지들이나 룰들을 모아서 설정으로 만든 것이 eslint-config-\\* 패키지다. 예를들면, eslint-config-airbnb는 eslint, eslint-plugin-import, eslint-plugin-react, eslint-plugin-react-hooks, eslint-plugin-jsx-a11y의 룰들을 조합한 설정 패키지이고 아래와 같이 정의해서 사용한다.\n\neslint-plugin-\\* 패키지의 설정은 extends에서 plugin:패키지네임/설정네임으로 사용할 수 있는데 eslint-config-\\* 패키지의 설정은 바로 \\*를 써주기만 하면 된다. 플러그인 패키지를 plugins에 단축어로 쓰던 것과 동일하다.\n\nparser\n\n말 그대로 코드를 분석하기 위한 파싱툴인데, 기본값은 espree이다. 하지만 보통 js 워크스페이스에서는 @babel/eslint-parser를 사용하고 ts 워크스페이스인 경우 @typescript-eslint/parser를 사용한다. 사실 plugin:@typescript-eslint/recommended를 포함시키면 @typescript-eslint/parser가 자동으로 포함되기도 한다.\n\nenv\n\n사전 정의된 전역 변수를 제공한다. node 환경인 워크스페이스면 node: true를 추가해야 하고, 웹 환경이라면 browser: true, es6: true 등을 추가해야 한다. files나 overrides를 사용해서 파일 패턴 단위로 적용할 전역 변수를 나눌 수도 있다. (물론 다른 설정도 마찬가지다)\n\n참고\n\nhttps://eslint.org/\n\nhttps://github.com/yrnana/nana-vite-template/blob/main/default/.eslintrc\n"},{"slug":"2021-10-25-when-should-you-not-use-react.memo","title":"Q. When should you NOT use React.memo?","body":"얕은 비교와 리액트 성능 최적화\n\n사내 FE모임 시간에 효율적인 스토리북 활용법에 대해 토론하다 \"스토리북의 Control 패널을 활용하려면 렌더링 최적화가 어렵다\" 라는 이야기를 하게 되었다. 그러다 인턴🤗분께서 PureComponent를 통한 얕은 비교로 렌더링 최적화를 하는건 어떻냐고 질문을 주셨는데, 덕분에 겉핥기로만 어렴풋이 알고 있던 리렌더링과 얕은 비교에 대해 좀더 생각해보게 된 것 같다.\n\nReact.memo\nReact.PureComponent\nshouldComponentUpdate\n\n세가지 케이스 모두 얕은 비교를 통해 개발자가 컴포넌트의 리렌더링을 제어할 수 있는 기능을 제공한다. (useMemo는 역할이 조금 다르다) 리액트는 기본적으로 상위 컴포넌트가 렌더링이 되면 무조건 리렌더링을 수행하는 특성을 가지고 있으나 React.memo나 React.PureComponent로 감싸게 되면 컴포넌트는 props가 변경되었을때만 리렌더링이 된다.\n당연하지만 얕은비교연산 ===가 어지간하면 리렌더링보다는 비용이 적게 들긴 한다. 그렇다면 왜 리액트는 React.memo나 React.PureComponent를 기본형으로 갖지 않을까?\n\nstate의 위치를 확인하자\n\n이러한 코드에서 Parent의 num1이 변경되면 Child2와 Child3도 리렌더링이 된다.\n\n이렇게 각 자식 컴포넌트를 PureComponent로 만들거나 React.memo로 감싸면 얕은비교를 통해 props가 변경될때만 렌더링이 될 것이다. 하지만 이렇게 하는 것 보다 더 좋은 방법이 있다.\n\nstate를 그냥 각각의 Child가 가지면 된다. 이렇게 상태를 가능한 Leaf Node로 전달하면 불필요한 리렌더링을 피할 수 있는 것이다.\n\nstate를 Leaf Node로 변경할 수 없는 경우\n\nExpensiveAndHeavyComponent는 React.memo로 감싸지 않으면 input에 값을 입력할때마다 value라는 state가 변경되면서 리렌더링이 될 것이다. 이 케이스는 state를 Leaf Node로 전달할 수 없는데 어떻게 최적화를 할 수 있을까?\n\n상위 컴포넌트가 변경되어도 리렌더링이 되지 않는 children props의 특성을 활용할 수 있을 것 같다. React.createElement의 세번째 인자로 넘기는 값이고, 이 역시 얕은비교를 통해 리렌더링 여부를 결정하기 때문이다.\n\nhttps://twitter.com/cherthedev/status/1141706784178167810\n\n리렌더링을 막기 위해 메모를 하거나 얕은 비교를 하는 것 보다, state의 위치를 확인하고 그냥 state를 내리는게 최고의 방법일 수도 있다!\n\nReact.memo의 오작동\n\nReact.memo로 감싼 컴포넌트의 경우 children props를 사용하고 JSX Element를 전달하면 의도한대로 작동하지 않고 계속 렌더링이 된다.\n\n최적화에 정답은 없다\n\nPureComponent나 React.memo를 통한 최적화는 분명 간단하지만 만능은 아니며, 불필요한 리렌더링이 자주 일어난다면 코드 구조 자체를 고민해볼 필요가 있다. 물론 렌더링이 거의 일어나지 않는 화면이라면 시간낭비일수도 있다. 리렌더링에 대해서는 \\<div />를 한 뎁스 더 그리는게 시간이 더 걸리니 React.memo를 쓸지 말지 고민할 시간에 불필요한 div를 줄이라는 분석도 존재한다. 맨날 적는 얘기지만 Performance Optimization에 정답은 없고, 여러가지 케이스 중 최적의 결과를 도출하는 것이 개발자의 역할이 아닌가 싶다.\n\n참고\n\nhttps://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo\n\nhttps://github.com/facebook/react/issues/14463\n\nhttps://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#memoize-everything\n\nhttps://overreacted.io/before-you-memo/\n\nhttps://kentcdodds.com/blog/optimize-react-re-renders\n"},{"slug":"2021-11-28-lodash-lodash-es","title":"lodash 대신 lodash-es 쓰자","body":"자바스크립트 유틸 라이브러리인 lodash는 자바스크립트 개발자들이 가장 많이 사용하는 라이브러리 중 하나다. 비슷한 라이브러리로 underscore가 있는데, lodash가 underscore의 superset 개념이고 성능이 더 우수하다고 한다.\n\n프론트엔드에서는 전송 사이즈를 줄이기 위해 tree shaking 즉 사용하지 않는 코드를 제거하는데, webpack이나 rollup 등의 번들러에 포함된 기능이다. 다만 es6 형식으로 export 된 라이브러리가 아니라면 트리셰이킹을 적용하기 어렵다. (commonJS 방식의 라이브러리를 트리셰이킹 하는 것이 아예 불가능한 것은 아니나, 잘 안 될 가능성이 높다)\n\nlodash 또한 아래와 같이 작성해도 트리셰이킹이 적용되지 않는다.\n\n\n\nlodash는 꽤 용량이 큰 라이브러리라, 무심코 트리셰이킹이 되었다고 생각하고 쓰지 않도록 주의해야 한다. 이를 해결하기 위한 방법은 아래와 같다.\n\nes6 구문으로 쓰여진 lodash-es를 사용한다. ✅\n\ncherry-picking 한다.\n\nbabel-plugin-lodash를 설치한다.\n\n이 중에서는 lodash-es를 사용하는 방법이 간편하다.\n\n참고\n\nhttps://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking\n"},{"slug":"2021-12-08-blog-move","title":"블로그 이사 후기","body":"블로그 옮긴 이유\n\n가 편하고 좋긴 한데 코드 블록이 마음에 안들어서 옮겼다.\n\n기술 스택\n\nGatsby(v4)\n\nTypeScript\n\nTailwind CSS\n\n나는 리액트와 타입스크립트의 노예니까 당연히 TS 기반으로 진행하려고 했다. 문제는 Next.js를 쓰느냐, Gatsby를 쓰느냐 였는데, 요즘 워낙 Next.js가 잘나가다보니 했다.\n\n다 만들고보니 블로그 개발 이라는 테마에 있어서 오히려 단점이 몇가지 있었다.\n\n마크다운 파싱 함수, 페이징 api 등 전부 직접 개발해야 함\n\n개발모드에서 마크다운을 수정해도 HMR 적용되지 않음\n\npostcss 컴파일 속도가 너무 느림\n\nSSG 모드에서는 이미지 최적화 기능을 지원하지 않음\n\n그래서 결국 Gatsby로 갈아 엎었는데 위와 같은 단점을 해결할 수 있었다. Gatsby의 경우 GraphQL로 마크다운 및 여러가지 파일들을 조회하고 가공할 수 있도록 제공하기 때문에 매우 편리하다.\n\nGatsby\n\nGatsby는 개발자가 각종 세팅을 쉽게 적용할 수 있도록 여러가지 플러그인을 제공하고 있다. 처음에 마크다운 프로세서 플러그인으로 gatsby-plugin-mdx를 사용했다가 gatsby-transformer-remark로 바꿨는데, 이는 일부 플러그인 (e.g. gatsby-remark-katex)이 디펜던시 문제로 후자에서만 작동하기 때문이다. 알고리즘 관련 포스트를 작성하려면 수식 작성이 필요해서 katex를 버릴 순 없었다.\n\n그리고 graphql-codegen으로 Type을 자동 생성하여 타입스크립트를 십분 활용할 수 있도록 적용했다. 또한 GraphQL 스키마는 대부분 auto detecting을 하는데, gatsby-node.js에서 스키마를 직접 지정 & 확장해서 GraphQL를 aggregate도 하고 graphql-codegen의 타입 output을 좀더 명확하게 지정할 수 있었다.\n\n처음엔 ts 파일로 gatsby-\\* 설정 파일들을 작성했는데, ts-node나 추가 플러그인을 설치해야 하는 점도 별로고 js 파일로 작성해야 초기 로드가 빠를 것 같아서 그냥 js 파일을 사용하고 IDE의 타입 지정 코멘트를 활용했다.\n\nMarkdown\n\n블로그이니만큼 가장 공을 들인 부분이 마크다운 프로세싱인데, 사실 Gatsby에서 기본적인 처리는 다 해주기 때문에 부가적인 처리만 해주면 된다. 다만 초기에 Next.js로 개발할 때는 직접 파싱하고 뿌려야 했기 때문에 나름대로 학습을 했다. 마크다운을 처리할때는 보통 unified라는 syntax tree로 텍스트를 처리하는 인터페이스를 활용한다. 비단 마크다운만 처리하는 용도는 아니고, markdown, natural language, html 을 지원하고 포맷간 변환을 지원한다.\n\n\n\ninput을 parser를 통해 syntax tree로 파싱하고 이 tree를 transformer를 통해 가공한 뒤 compiler로 output을 만들 수 있다. 즉, 마크다운 파일이 input이라면 이를 mdast(markdown syntax tree)로 만들고 여기에 어떠한 처리 (e.g. autolink) 를 한 뒤 html string으로 변환하는 것이다. 아니면 mdast를 hast(html syntax tree)로 바꾸고 가공 후 html으로 변환해도 된다.\n\nGraphQL에서 html과 htmlAst(hast) 두가지를 제공하는데, 나는 dangerouslySetInnerHTML을 사용해서 html을 출력하는 대신 위의 stringify 단계를 rehype-react라는 컴파일러로 처리했다.\n\n또한 Gatsby v4에서 지원하지 않는 일부 플러그인을 \\<root>/plugins에 직접 작성해서 gatsby-config.js에 적용했는데, 이 때 주의할 점은 현재 unified 관련 패키지들은 전부 ESM only 인데 gatsby-config.js는 노드 환경에서 돌아가기 때문에 오류가 난다. 따라서 이 패키지들은 cjs를 지원하는 낮은 버전으로 다운그레이드 해서 설치해야 한다. (e.g. remark-breaks)\n\n이사 한달 후기\n\nlighthouse에서 SEO 만점이 나오는데도 검색에 안 걸린다ㅠㅠ\n벨로그는 검색에 정말 잘 걸리는게 큰 장점인듯...\n그리고 좋아요 같은 기능을 붙이고 싶어서 언젠가는 SSR로 옮길까 하고 도메인을 붙였다.\n\n이사 5달 후기\n\n검색에 꽤 잘 걸린다... velog 때도 그렇지만 은근 검색이 잘 걸리는 편인듯... 왤까요... 좋은데 싫어(?)... 지금이라도 존댓말 쓸까요?🥺\n"},{"slug":"2021-12-09-next.js","title":"Next.js에서 카카오맵 사용하기","body":"카카오맵 typescript 지원\n\n.env\n\nKakaoMap 컴포넌트\n\n이렇게 하는 이유는 useEffect가 onLoad보다 먼저 실행되기 때문이다. 그런데 Script는 최초 한번만 로드되므로 onLoad로만 initMap을 할 수는 없다.\n\\&autoload=false는 js↦document.write를 사용하지 않고 js↦kakao.maps.load(callback)로 모듈을 불러올 수 있도록 하는 쿼리다.\n"},{"slug":"2021-12-10-next-auth","title":"next-auth와 카카오 로그인 연동","body":"\\~~next-auth가 v4로 업데이트 되면서 기존  코드를 적용하면 돌아가지 않아서 정리해본다.~~\n\n2022.04.10 기준 카카오 프로바이더도 업데이트가 되어서 추가 설정없이 적용할 수 있다.\n\ninstall packages\n\nprisma/schema.prisma\n\n\\~/helpers/prisma.ts\n\n.env\n\npages/api/auth/\\[...nextauth].ts\n\n이 패키지 덕분에 Next.js에서 카카오 로그인을 쉽게 해결할 수 있었다.\n"},{"slug":"2022-02-04-enum-union-type","title":"enum 보다 union type을 사용하자","body":"union type을 사용하는게 좋은 이유\n\nenum을 쓰는 경우\n\n이를 tsc로 트랜스파일링 후 rollup으로 번들링하면 아래와 같이 변환된다.\n\nunion type을 쓰는 경우\n\n이를 트랜스파일링 및 번들링 하면 아래와 같다.\n\nunion type을 쓰는 경우 장점\n\njs로 변환시 코드가 줄어든다. enum은 js로 트랜스파일링 될때 타입과는 달리 사라지지 않기 때문에 코드양을 증가시킨다.\n\nenum과 달리 import를 하지 않아도 사용할 수 있다. (컴포넌트의 props 등에 지정되어 있을때)\n\nenum보다 선언 방법이 간단하다. ts↦type Fruit = 'Apple' | 'Orange' | 'Grape'\n\nunion type을 사용해도 ide (e.g. vscode)의 auto complete 기능이 활성화된다.\n\n같이 보면 좋은 tsconfig.json 옵션\n\nesModuleInterop (default: false)\n\n이 옵션이 false 또는 not set 이라면 CommonJS/AMD/UMD 모듈을 ESM처럼 취급한다.\n문제가 되는 경우는 아래처럼 CJS 모듈을 ESM 코드베이스로 가져오려고 할 때다.\n\nesModuleInterop를 활성화하면 ESM 사양에 따라 CJS 모듈을 가져올 수 있다.\n\nisolatedModules (default: false)\n\nBabel이나 다른 빌드툴은 한번에 하나의 하나의 파일에서만 작동하므로 const enum이나 namespace같은 타입스크립트 기능을 사용하는데 런타임 문제가 발생할 수 있다. 이 옵션을 true로 설정하면 단일 파일 변환 프로세스에서 올바르게 해석할 수 없는 코드를 작성할 경우 경고를 받게 된다.\n대표적으로 모든 실행 파일들은 모듈이어야 한다는 규칙이 있다.\n\nimportsNotUsedAsValues (default: remove)\n\nimport가 어떻게 처리되는지를 결정하는 플래그이다.\n\nremove : 참조 타입만 drop\n\npreserve : 사용되지 않는 값이나 타입들도 전부 보존한다. side-effects를 일으킬 수도 있음\n\nerror : 모든 import를 보존하지만, value import가 값처럼 사용되면 error을 출력\n\npreserveValueImports (default: false)\n\n타입스크립트가 import를 사용하고 있음을 감지하지 못하는 경우가 있다. Svelte나 Vue처럼 Compiles to HTML 언어를 사용하거나 아래와 같은 경우다.\n\nisolatedModules 옵션과 함께 사용되는 경우, import 된 타입은 컴파일러가 이 import 가 사용되지 않는 값인지 또는 삭제되어야 하는 type 인지 알 수 없기 때문에 type-only로 지정해야 한다.\n\n참고\n\nhttps://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/\n\nhttps://newbedev.com/understanding-esmoduleinterop-in-tsconfig-file\n"},{"slug":"2022-03-02-typescript-4.6","title":"TypeScript 4.6에 추가된 기능","body":"타입스크립트 4.4에 이어 더욱 강화된 제어 흐름 분석 (Control Flow Analysis) 기능이 마음에 들어서 쓰는 글으로, 이 외의 기능은 생략한다. 타입스크립트 4.6에는 이 외에도 생성자에서 super() 이전에 코드 사용을 허용하는 것, 향상된 재귀 깊이 검사, 인덱싱 된 액세스 추론 개선, 자바스크립트에서 좀더 많은 syntax error 및 binding error 제공 등의 기능을 추가했으니 을 가볍게 읽어보면 좋을 것 같다.\n\n구조분해된 판별 유니언(Discriminated Unions)에 대한 제어 흐름 분석\n\n유니언 타입은 number | string과 같이 타입 여러개를 조합하여 만들 수 있는 타입이다. 판별 유니언(Discriminated Unions)은 아래와 같이 판별 프로퍼티를 갖는 타입의 유니언이다.\n\n예전에 에서는 타입가드 함수를 선언하지 않아도 아래와 같은 구분이 가능하도록 기능이 추가되었다.\n\n그러나 아래와 같이 동일한 객체에서 구조분해된 이후에는 완전히 독립적인 것으로 간주되었었는데, 이번 4.6부터는 구조분해 된 타입이 판별 유니언인지 확인 후 판별 유니언이 맞다면 다른 변수 값에 따라 변수 유형을 좁히게 된다.\n\n따라서 위와 같은 사용이 가능하다.\n\n의존 매개변수에 대한 제어 흐름 분석\n\n위와 같은 코드를 작성한다면 Func타입 함수의 인수는 첫번째 인수에 의존하게 되고 이 경우 다른 인자의 유형을 좁힐 수 있다. 주의할 점은 반대로 payload의 타입을 if문으로 확인한다고 해서 kind의 타입이 좁혀지는 것은 아니다. 이건 위의 경우도 마찬가지로, 판별 프로퍼티로만 판별이 가능하다는 점을 주의해야 한다.\n\n참고\n\nhttps://devblogs.microsoft.com/typescript/announcing-typescript-4-6/\n"},{"slug":"2022-04-12-react-18","title":"React 18 둘러보기","body":"지난 3월말에 아기다리고기다리던 React v18이 출시되었다. 17.0.2에서 머물러있던 리액트가 마이너 업데이트 없이 메이저 업데이트를 진행했는데, 그동안 실험 기능으로 던져온 떡밥들을 해소하는 업데이트가 될 것 같다.\n\n새로운 기능\n\nAutomatic Batching\n\n은 리액트가 여러개의 상태 업데이트를 하나의 리렌더링으로 그룹핑 하는 것이다. 이전에는 리액트 이벤트 핸들러에서만 배칭을 지원했고, promise, setTimeout, native 이벤트 핸들러 등에서는 배칭이 되지 않았다.\n\nTransitions\n\n\n\n이제 앨리스랑 전화 도중 급하게 걸려온 밥의 전화를 받고 나서 다시 앨리스와 통화할 수 있다.\n\nTransition은 React 16 시절부터 던져온 Concurrent Mode 떡밥을 정리하는 새로운 기능이다. (timeoutMs 등은 스펙아웃 되었으니 hooks api를 확인할 것)\nSynchronous 렌더링 중에는 한번 렌더링이 시작되면 결과물을 화면에서 보기 전까지는 아무것도 막을 수 없지만, concurrent에서 렌더링은 중단될 수 있다.\n\n긴급한 업데이트 (urgent updates) : 입력, 클릭, 누르기 같은 다이렉트 상호작용을 반영\n\n전환 업데이트 (transition updates) : UI의 전환\n\n타이핑, 클릭, 누르기 같은 긴급 업데이트는 빠르게 업데이트 되지 않으면 버벅거리면서 앱이 이상하다는 느낌을 줄 수 있다. 하지만 화면은 곧바로 결과값을 볼거라고 기대하지 않기 때문에 전환 업데이트는 느리게 업데이트가 되어도 괜찮다.\n\n위와 같이 startTransition으로 래핑된 업데이트는 전환 업데이트로 처리되며, 긴급한 업데이트가 들어오면 중단된다. 전환이 중단되면 리액트는 stale한 렌더링 작업을 버리고 마지막 업데이트만을 렌더링한다.\n\n아래와 같은 코드는 탭을 photos에서 comments로 바꾸면서 의도치않게 \\<Spinner />를 노출할 수 있다.\n\n이때 만약 \\<Photos /> UI를 계속 노출하기 원한다면 tab을 바꾸는 것을 지연하면 된다. 즉, startTransition로 감싸는 것은 setTab('comments')는 급하지 않은 전환 업데이트라는 것을 표시하는 것이다.\n\nSuspense\n\nSuspense를 사용하면 로드 상태를 선언적으로 지정할 수 있다. Suspense는 v16에서 도입되었는데, 이전에는 React.lazy를 활용한 코드 스플리팅만 지원했으며 서버 렌더링은 지원하지 못했다. v18에서는 서버 렌더링에서의 지원을 추가했다고 한다.\n\nSuspense가 로드 상태를 나타내는 방법은 에러 바운더리가 에러 상태를 캐치하는 방법과 유사한데, 이 경우 데이터가 아직 fetch 되지 않았다거나 코드가 로드되지 않았다거나 해서 렌더링 될 준비가 되지 않았음을 나타낼 수 있다. 동작 또한 에러 바운더리와 유사하게 구성 요소 위에 가장 가까운 구성 요소가 캐치 되고 해당 Suspense의 fallback 컴포넌트로 대체된다.\n\n만약 showComments가 false에서 true로 변경되면서 \\<Comments />에서 데이터 fetch로 인해 정지가 걸린다고 가정하면, 내부 동작은 다음과 같다.\n\nPanel은 고려하지 않는다.\n\nSpinner를 DOM에 넣는다.\n\nComments가 완료될때까지 기다린다.\n\n렌더링을 시도한다.\n\nSpinner를 DOM에서 제거한다.\n\nComments와 함께 Panel을 DOM에 넣는다.\n\nPanel의 effects를 실행한다.\n\nSuspense와 Transition\n\n앞서 Transition 항목에서 언급한 대로 Suspense는 Transition API와 결합해서 사용하면 가장 잘 작동한다. 전환 업데이트가 중단되면 리액트는 이미 보이는 컨텐츠가 Spinner와 같은 fallback 컨텐츠로 대체되는 것을 방지할 수 있다. 대신 리액트는 데이터가 충분히 로드될 때까지 렌더링을 지연할 것이다.\n\n새로운 클라이언트 및 서버 렌더링 API\n\n클라이언트\n\nReactDOM.render를 사용하는 대신 아래와 같이 선언해야 한다.\n\n이외에는 서버 사이드와 관련된 내용이라 생략...나는 믿을거야 nextjs 믿을거야 👀\n\n새로운 Hooks\n\nuseId\n\nuseId는 client-server사이드에서 hydration 미스매치를 피하기 위해서 unique ID를 만들어주는 훅이다. 단, list의 key를 만들어주기 위한 훅이 아니니 그렇게 사용하지 말자.\n\nuseTransition\n\nuseTransition과 startTransition은 일부 상태 업데이트를 급하지 않은 업데이트로 간주한다. concurrent에서는 급한 상태 업데이트가 급하지 않은 상태 업데이트를 중단할 수 있다.\n\nuseDeferredValue\n\nuseDeferredValue는 급하지 않은 트리를 리렌더링 하는 것을 지연하게 해준다. 지연된 렌더링은 중단될 수 있고, 사용자의 입력을 방해하지 않는다. 디바운싱 / 쓰로틀링 기법과 유사하지만 timeout을 직접 지정할 필요 없이 리액트가 다른 급한 작업이 완료 되는 즉시 실행을 시킨다는 장점이 있다.\n\nuseSyncExternalStore\n\n라이브러리 개발을 위해 제공된 훅이다. (글로벌 상태관리)\n\nuseInsertionEffect\n\n라이브러리 개발을 위해 제공된 훅이다. (CSS-in-JS)\n\nuseTransition vs useDeferredValue\n\n을 읽고 나니 상태 제어가 가능할때는 useTransition를 사용하고 props에서 값에만 접근이 가능한 경우엔 useDeferredValue를 사용하면 좋을 것 같다.\n다만 항상 디바운싱을 사용하지 않는 것 처럼, 이 훅들도 항상 사용할 필요는 없다. 예를 들면 만개의 리스트를 렌더링 하고 사용자가 입력한 값을 받아서 필터링이 필요한 상황이라고 해보자. 이 경우, useTransition이나 useDeferredValue를 사용하는 것 보다 가상화 리스트를 적용하는 것이 성능적으로 훨씬 우수하다. 성능 최적화에는 다양한 방법이 있기 때문에 이번 업데이트로 옵션이 추가된 것으로 받아들이면 좋을 것 같다.\n그러나 위와 같이 에서는 startTransition을 통한 Suspense 트리거 방지가 필요하다. 아마 이런 처리는 react-query와 같은 데이터 fetch 라이브러리들이나 react-router-dom과 같은 라우터 라이브러리가 맡아서 내부적으로 처리하지 않을까 싶다.\n\n여담\n\n토이 프로젝트는 react v18을 설치해서 쓰고 있는데, 아직은 서드파티 라이브러리들이 미지원인 경우가 많아서 때문에 타입에서 오류가 나기도 하고 concurrent를 지원하지 않는 경우도 많다. 프로덕션 마이그레이션을 목표로 한다면 주요 라이브러리의 v18 지원 여부를 확인할 필요가 있을 것 같다.\n전반적으로 퍼포먼스 개선과 서드파티 라이브러리 지원을 위한 업데이트가 많은 듯 하고, 리액트가 라이브러리로서 출범했다면 이러한 hooks api를 제공하고 제어함으로서 어떻게보면 에코시스템이 되어가는 과정이 아닌가 싶다.\n\n참고\n\nhttps://reactjs.org/blog/2022/03/29/react-v18.html\n\nhttps://github.com/reactwg/react-18/discussions\n\nhttps://github.com/reactwg/react-18/discussions/46\n\nhttps://github.com/reactwg/react-18/discussions/100\n\nhttps://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md\n\nhttps://academind.com/tutorials/react-usetransition-vs-usedeferredvalue\n"},{"slug":"2022-04-26-react-query","title":"React Query 사용시 주의할 점","body":"React Query 를 1년간 사용하면서 요즘들어 내가 잘 모르고 사용했구나 생각한 적이 종종 있어서, 복기를 해보고자 한다.\n\nuseQuery의 onSuccess, onError 등은 선언한 인스턴스의 수만큼 실행된다\n\n예를 들면 아래와 같이 사용한다고 하자.\n\n\\<Child /> 컴포넌트가 3개 선언되었으므로 useUserQuery() 인스턴스는 총 3개 생성되었다. 이렇게 되면 queryFn인 getUser는 한번만 호출되지만, onSuccess는 쿼리 인스턴스 갯수만큼, 즉 3번 실행된다. onSuccess 뿐만이 아니라 이렇게 지정되는 모든 옵션은 인스턴스 갯수만큼 실행된다. 따라서 useSelector처럼 useCustomQuery를 쓴다면 이 부분을 주의해야 한다.\n\nsuspense 모드를 사용하면 쿼리가 직렬로 실행된다\n\nhttps://react-query.tanstack.com/guides/parallel-queries\nWhen using React Query in suspense mode, this pattern of parallelism does not work, since the first query would throw a promise internally and would suspend the component before the other queries run. To get around this, you'll either need to use the useQueries hook (which is suggested) or orchestrate your own parallelism with separate components for each useQuery instance (which is lame).\n\n다만 실제로 react-query v3 / v4 + suspense true / false + useQuery / useQueries 다양한 조합으로 네트워크 테스트를 수행했을때 별다른 차이는 없었다.\n\nReact Query v3의 suspense 모드는 experimental 기능이다.\n\n리액트에서 data fetch에 따른 suspense(지연) 모드는 React 18에서 도입된 기능이고, 이전까지는 React.lazy를 활용한 코드 스플리팅만 지원했다. 그런데  마법처럼 이 기능을 사용할 수 있었다. 다만, React Query 문서에서 나왔듯이 이는 experimental 기능이며 React 17에서 실행하게 되면 React 18의 정식 기능과는 차이가 존재한다.\n\n위와 같은 코드가 있고, Wrapper, Fallback, DataFetch 각각에 useEffect를 둔다면 실행 순서는 다음과 같다.\n\nReact 17 : Wrapper -> Fallback -> Child\n\nReact 18 : Fallback -> Child -> Wrapper\n\nsuspense 모드를 사용한다면 이런 차이점들을 인지해야 할 것 같다.\n"},{"slug":"2023-03-22-calculation-is-expensive","title":"비싼 연산의 기준은 무엇일까?","body":"리액트에서 useMemo는 성능 최적화를 위해 비싼 연산에만 사용하라고 강조한다. 그런데 이 비싸다는 기준은 어떻게 판단해야 할까?\n매번 프로파일러를 켜서 성능을 측정하는 것도 쉬운 일은 아니기 때문에 고민이 되었었는데, 이번에 새로 작업된 리액트 공식 문서에서는 다음과 같은 기준을 제시하였다.\n\n문서에서는 만약 기록된 실행 시간이 상당한 양 (예를 들면, 1ms 이상)인 경우, 해당 계산을 메모하는 것이 합리적일 수 있다고 설명한다.\n물론 개발모드에서는 프로덕션용 앱과 타이밍이 다를 수 있다는 점, 시스템(개발용 맥북)과 실제 사용자의 시스템(나의 경우 스마트폰)이 다를 수 있다는 점은 감안해야 한다.\n\n참고\n\nhttps://react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive\n"},{"slug":"2023-03-23-react-query-2","title":"React Query 사용시 주의할 점 2","body":"숨 쉬었는데 1년 지난거 실화인감?\n아무튼 너무 사내 정보글만 적어서 블로그도...\n\nconst { reset } = useQueryErrorResetBoundary()의 reset 함수는 cache invalidate를 trigger 하는 함수가 아니다\n\n와 함께 많이 사용하는 useQueryErrorResetBoundary는 메서드 이름이나 용법만 보면 현재 실행되어 있는 모든 쿼리의 상태값을 reset 하는 메서드 처럼 보인다.\n\n하지만 실제로 를 살펴보면 아래와 같이 매우 단순한 구조로 작성되어있음을 알 수 있다.\n\nreset()은 isReset()을 true로 변경시키고, 그로 인해 useBaseQuery의 내부 코드에서 getHasError가 false를 가지도록 하면서 그 순간에는 throw error가 되지 않는다. 최초 렌더링 이후에는 가 실행되면서 isReset()는 다시 false를 반환하게 된다.\n\n즉, reset() 메서드가 cache invalidate를 trigger 한다고 생각하기 쉽지만, 실제로는 react-error-boundary 라이브러리가 onReset에 매칭한 함수를 실행하면 에러 상태를 풀고 fallback 컴포넌트에서 다시 children 컴포넌트를 마운트 하면서 children 컴포넌트의 useQuery들이 refetchOnMount로 인해 호출되는 것 뿐이다.\n\n여기서 발생할 수 있는 문제가 아래와 같은 옵션의 쿼리를 refetch 메서드로 호출했다가 오류가 발생하는 케이스다.\nenabled: false 이므로, 다시 mount 되더라도 refetch가 되지 않았다가 리렌더링이 한번이라도 일어난 시점에서 오류를 발생시킨다.\n\n이런 경우는 쿼리의 cacheTime을 짧게 잡거나, 사실 useMutation을 쓰는게 맞는 것 같다.\n\nuseQuery에서 반환하는 refetch를 사용할 때 오류 옵션을 확인하자\n\nthrowOnError라는 옵션이 있는데 기본값이 false이다.\n이 값이 없으면 refetch 발생시 오류가 발생하더라도 로직이 중단되지 않는다. (ㅠㅠ)\n"},{"slug":"2023-09-15-debounce-throttle","title":"debounce 및 throttle를 react에서 사용할 때 주의할 점","body":"debounce, throttle이란?\n\ndebounce와 throttle은 성능 향상을 위해 함수 실행을 지연시켜 함수의 빈번한 호출을 제한하는 프로그래밍 패턴 또는 기술이다. 아래와 같은 차이점이 존재한다.\n\n디바운싱\n\n함수를 다시 호출하기 전에 일정 시간 동안 기다림\n\n이벤트가 여러 번 트리거 되더라도 함수가 한 번만 호출되도록 함\n\n특정 비활성 기간이 지날 때까지 함수 호출을 지연하려는 경우 유용함\n\n쓰로틀링\n\n특정 시간 동안 함수가 호출될 수 있는 횟수를 제한함\n\n이벤트가 여러 번 트리거 되는 경우에도 함수가 정기적으로 호출되도록 함\n\n함수 호출 빈도를 나열하려는 경우 유용함\n\n&#x20;등으로 쉽게 사용이 가능하다.\n\n문제\n\n위의 코드는 1s 동안 setCount 실행을 방지하기 위해 debounce를 적용하였지만, 의도한 대로 작동하지 않는다.\n이유는 함수가 실행될 때 count가 증가하면서 리렌더링이 발생하고, 그때마다 debounce 함수가 재실행되면서 새로운 함수가 생성되어 debounce의 타이머 처리가 무의미해지기 때문이다.\n리렌더링이 발생하지 않는 컴포넌트라면 위와 같이 사용해도 대응이 가능하지만, 대부분의 리액트 컴포넌트는 렌더링을 가정하고 작성하기 때문에 의도하지 않는 동작이 될 수 있다.\n\n해결방법\n\n따라서 아래와 같은 훅을 작성해서 대응이 가능하다. 이렇게 작성하면 useLayoutEffect에 의해서 함수 인자가 변경되더라도 debounce에서 변경된 함수를 실행하지만, 리렌더링으로 인한 debounce 함수의 재호출은 방지할 수 있다.\n\n참고\n\nhttps://css-tricks.com/debouncing-throttling-explained-examples/\n\nhttps://epicreact.dev/how-react-uses-closures-to-avoid-bugs/\n"}]