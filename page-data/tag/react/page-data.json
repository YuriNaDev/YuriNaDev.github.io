{
    "componentChunkName": "component---src-templates-post-list-by-tag-template-tsx",
    "path": "/tag/react",
    "result": {"data":{"allMdx":{"nodes":[{"slug":"2021-10-25-when-should-you-not-use-react.memo","excerpt":"당연하지만 얕은비교연산 `===`가 어지간하면 리렌더링보다는 비용이 적게 들긴 한다. 그렇다면 왜 리액트는 `React.memo`나 `React.PureComponent`를 기본형으로 갖지 않을까?","frontmatter":{"title":"Q. When should you NOT use React.memo?","date":"2021-10-25T07:30:46+09:00","tags":["React","Optimization"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\uB2F9\\uC5F0\\uD558\\uC9C0\\uB9CC \\uC595\\uC740\\uBE44\\uAD50\\uC5F0\\uC0B0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"===\"), \"\\uAC00 \\uC5B4\\uC9C0\\uAC04\\uD558\\uBA74 \\uB9AC\\uB80C\\uB354\\uB9C1\\uBCF4\\uB2E4\\uB294 \\uBE44\\uC6A9\\uC774 \\uC801\\uAC8C \\uB4E4\\uAE34 \\uD55C\\uB2E4. \\uADF8\\uB807\\uB2E4\\uBA74 \\uC65C \\uB9AC\\uC561\\uD2B8\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.memo\"), \"\\uB098 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.PureComponent\"), \"\\uB97C \\uAE30\\uBCF8\\uD615\\uC73C\\uB85C \\uAC16\\uC9C0 \\uC54A\\uC744\\uAE4C?\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"당연하지만 얕은비교연산 `===`가 어지간하면 리렌더링보다는 비용이 적게 들긴 한다. 그렇다면 왜 리액트는 `React.memo`나 `React.PureComponent`를 기본형으로 갖지 않을까?"}}},{"slug":"2021-08-21-context-api-redux","excerpt":"context api는 글로벌 상태관리 라이브러리를 대체할 수 없고, 여전히 많은 리액트 개발자들이 redux, mobx 등을 사용하고 있다.","frontmatter":{"title":"Context API가 존재하지만 여전히 사람들이 redux와 전역 상태관리 라이브러리를 쓰는 이유","date":"2021-08-21T16:31:55+09:00","tags":["Jotai","React","Recoil","context API","Redux"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"context api\\uB294 \\uAE00\\uB85C\\uBC8C \\uC0C1\\uD0DC\\uAD00\\uB9AC \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB97C \\uB300\\uCCB4\\uD560 \\uC218 \\uC5C6\\uACE0, \\uC5EC\\uC804\\uD788 \\uB9CE\\uC740 \\uB9AC\\uC561\\uD2B8 \\uAC1C\\uBC1C\\uC790\\uB4E4\\uC774 redux, mobx \\uB4F1\\uC744 \\uC0AC\\uC6A9\\uD558\\uACE0 \\uC788\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"context api는 글로벌 상태관리 라이브러리를 대체할 수 없고, 여전히 많은 리액트 개발자들이 redux, mobx 등을 사용하고 있다."}}},{"slug":"2021-03-24-table-of-contents-using-intersection-observer-api","excerpt":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다.","frontmatter":{"title":"Table Of Contents using Intersection Observer API","date":"2021-03-24T23:05:36+09:00","tags":["React","Table Of Contents","Intersection Observer API"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Table Of Contents\\uB294 \\uBAA9\\uCC28\\uB97C \\uC758\\uBBF8\\uD558\\uACE0, Intersection Observer API\\uB294 \\uD0C0\\uAC9F\\uC694\\uC18C\\uAC00 \\uC0C1\\uC704\\uC694\\uC18C(\\uB610\\uB294 viewport)\\uC640 Intersect \\uD558\\uB294\\uC9C0 \\uAD00\\uCC30\\uD558\\uB294 \\uAE30\\uB2A5\\uC744 \\uC81C\\uACF5\\uD558\\uB294 Web API\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다."}}},{"slug":"2021-02-13-framer-motion-react-motion-gesture","excerpt":"framer-motion는 리액트에서 애니메이션과 제스쳐를 쉽게 다룰 수 있도록 해주는 라이브러리다.","frontmatter":{"title":"framer-motion : react를 위한 motion & gesture 라이브러리","date":"2021-02-13T02:14:33+09:00","tags":["React","Framer Motion"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"framer-motion\\uB294 \\uB9AC\\uC561\\uD2B8\\uC5D0\\uC11C \\uC560\\uB2C8\\uBA54\\uC774\\uC158\\uACFC \\uC81C\\uC2A4\\uCCD0\\uB97C \\uC27D\\uAC8C \\uB2E4\\uB8F0 \\uC218 \\uC788\\uB3C4\\uB85D \\uD574\\uC8FC\\uB294 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"framer-motion는 리액트에서 애니메이션과 제스쳐를 쉽게 다룰 수 있도록 해주는 라이브러리다."}}}]}},"pageContext":{"tag":"React"}},
    "staticQueryHashes": ["1957264973","5457840"]}