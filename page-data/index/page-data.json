{
    "componentChunkName": "component---src-templates-post-list-template-tsx",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"slug":"/post/2022-02-04-enum-union-type","excerpt":"union type을 사용하는게 좋은 이유 enum을 쓰는 경우 이를 tsc로 트랜스파일링 후 rollup으로 번들링하면 아래와 같이 변환된다. union type을 쓰는 경우 이를 트랜스파일링 및 번들링 하면 아래와 같다. union type을 쓰는 경우 장점 js…","frontmatter":{"title":"enum 보다 union type을 사용하자","date":"2022-02-04T22:25:00+09:00","tags":["typescript","enum","union type"],"excerptAst":null}},{"slug":"/post/2021-12-10-next-auth","excerpt":"next-auth가 v4로 업데이트 되면서 기존 카카오 프로바이더 코드를 적용하면 돌아가지 않아서 정리해본다. install packages prisma/schema.prisma ~/helpers/prisma.ts .env pages/api/auth/[...nexta…","frontmatter":{"title":"next-auth와 카카오 로그인 연동","date":"2021-12-10T21:25:23+09:00","tags":["Next.js","next-auth","snippet"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"next-auth"}]},{"type":"text","value":"와 카카오 로그인을 연동하는 방법"}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-12-09-next.js","excerpt":"카카오맵 typescript 지원 .env KakaoMap 컴포넌트 이렇게 하는 이유는 useEffect가 onLoad보다 먼저 실행되기 때문이다. 그런데 Script는 최초 한번만 로드되므로 onLoad로만 initMap을 할 수는 없다. &autoload=fals…","frontmatter":{"title":"Next.js에서 카카오맵 사용하기","date":"2021-12-09T05:15:53+09:00","tags":["Next.js","snippet"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Next.js"}]},{"type":"text","value":"에서 카카오 지도 sdk를 사용하는 방법"}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-12-08","excerpt":"블로그 옮긴 이유 velog가 편하고 좋긴 한데 코드 블록이 마음에 안들어서 옮겼다. 기술 스택 Gatsby(v4) Typescript Tailwind CSS 나는 리액트와 타입스크립트의 노예니까 당연히 TS 기반으로 진행하려고 했다. 문제는 Next.js를 쓰느냐,…","frontmatter":{"title":"블로그 이사 후기","date":"2021-12-08T10:54:27+09:00","tags":["etc"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"velog에서 깃헙 블로그로 이사한 이유와 개발 후기"}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-11-28-lodash-lodash-es","excerpt":"자바스크립트 유틸 라이브러리인 lodash는 자바스크립트 개발자들이 가장 많이 사용하는 라이브러리 중 하나다. 비슷한 라이브러리로 underscore가 있는데, lodash가 underscore의 superset 개념이고 성능이 더 우수하다고 한다. 프론트엔드에서는 …","frontmatter":{"title":"lodash 대신 lodash-es 쓰자","date":"2021-11-28T10:55:33+09:00","tags":["lodash"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"lodash-es"}]},{"type":"text","value":"를 써야 tree shaking이 된다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-10-25-when-should-you-not-use-react.memo","excerpt":"얕은 비교와 리액트 성능 최적화 사내 FE모임 시간에 효율적인 스토리북 활용법에 대해 토론하다 \"스토리북의 Control 패널을 활용하려면 렌더링 최적화가 어렵다\" 라는 이야기를 하게 되었다. 그러다 인턴🤗분께서 PureComponent를 통한 얕은 비교로 렌더링 최…","frontmatter":{"title":"Q. When should you NOT use React.memo?","date":"2021-10-25T07:30:46+09:00","tags":["React","Optimization","memo"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"당연하지만 얕은비교연산 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"==="}]},{"type":"text","value":"가 어지간하면 리렌더링보다는 비용이 적게 들긴 한다. 그렇다면 왜 리액트는 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"React.memo"}]},{"type":"text","value":"나 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"React.PureComponent"}]},{"type":"text","value":"를 기본형으로 갖지 않을까?"}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-09-02-eslint","excerpt":"ESLint란? javascript 코드에서 문제를 찾아주고 (find) 고쳐주는 (fix) 정적 코드 분석 도구다. create-react-app으로 리액트 앱을 런칭하면 기본적으로 eslint-config-react-app이라는 eslint 설정이 세팅되어 있다.…","frontmatter":{"title":"ESLint 알고 쓰기","date":"2021-09-02T20:40:01+09:00","tags":["ESLint"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ESLint를 이해하고 작성하는 방법"}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-08-29-redux-saga","excerpt":"redux-saga의 단점 생소한 generator 함수 ES6의 generator & yield는 비동기처리를 위한 함수인데 솔직히 프론트엔드 직무가 떡상한 시점에서 이미 더 간단하게 사용할 수 있는 ES7 async / await 가 등장했기 때문에 다소 생소한 …","frontmatter":{"title":"redux-saga를 추천하지 않는 이유","date":"2021-08-29T15:29:45+09:00","tags":["React Query","Redux","Redux Saga"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"서버 state를 관리하기 위해 글로벌 상태 관리 라이브러리에 비동기 처리를 위한 라이브러리를 붙일 필요는 없다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-08-28-typescript-4.4","excerpt":"정말 좋은 기능들이 추가되어서 정리해본다. alias 된 조건문과 판별문 흐름 분석을 컨트롤 위의 케이스는 기존 타입스크립트에서도 정상적으로 인식했다. 그런데 이렇게 typeof arg === \"string\"을 alias 하는 경우 인식을 못했었다. 그런데 타입스크립…","frontmatter":{"title":"Typescript 4.4에 추가된 기능","date":"2021-08-28T14:31:28+09:00","tags":["Typescript"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"정말 좋은 기능들이 추가되어서 정리해본다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-08-26-usememo","excerpt":"공식 설명에도 computeExpensiveValue라고 설명하고 있다. 즉 비싼 연산을 언급하는 것이다. 예를 들면 데이터 만개를 변경한다던가... a === b는 전혀 비싼 연산이 아니다! 이 경우, 메모하는 메모리 비용에다가 [a, b]로 들어간 디펜던시에서 리…","frontmatter":{"title":"간단한 연산에 useMemo 쓰지 말자","date":"2021-08-26T11:15:48+09:00","tags":["useMemo"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"공식 설명에도 computeExpensiveValue라고 설명하고 있다. 즉 비싼 연산을 언급하는 것이다. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a === b"}]},{"type":"text","value":"는 비싼 연산이 아니다!"}]}],"data":{"quirksMode":false}}}}],"pageInfo":{"currentPage":1,"pageCount":4,"hasNextPage":true,"hasPreviousPage":false}}},"pageContext":{"limit":10,"skip":0}},
    "staticQueryHashes": ["1957264973","5457840"]}