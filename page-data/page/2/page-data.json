{
    "componentChunkName": "component---src-templates-post-list-template-tsx",
    "path": "/page/2",
    "result": {"data":{"allMdx":{"nodes":[{"slug":"2021-04-16-useimperativehandle-forwardedref","excerpt":"useImperativeHandle 와  forwardedRef 를 활용하면 부모 컴포넌트가 자식 컴포넌트의 함수를 호출하거나 값을 가져올 수 있다.","frontmatter":{"title":"useImperativeHandle & forwardedRef 활용하기","date":"2021-04-16T21:49:11+09:00","tags":null,"excerpt":null}},{"slug":"2021-04-10-react-query-staletime-cachetime","excerpt":"React Query의 라이프 사이클 A 쿼리 인스턴스가 mount 됨 네트워크에서 데이터 fetch 하고 A라는 query key로 캐싱함 이 데이터는  fresh  상태에서  staleTime (기본값 0) 이후  stale  상태로 변경됨 A 쿼리 인스턴스가 u…","frontmatter":{"title":"React Query에서 staleTime과 cacheTime의 차이","date":"2021-04-10T12:33:59+09:00","tags":["React Query"],"excerpt":null}},{"slug":"2021-03-26","excerpt":"react vs vue vs angular vue 허접이 깝치지마라:-)\n https://www.npmtrends.com/react-vs-vue-vs-@angular/core ui library 의외로 material-ui가 월등하다. (antd랑 비슷한줄)\n htt…","frontmatter":{"title":"비슷한 라이브러리 비교해보는 글","date":"2021-03-26T01:07:55+09:00","tags":["library"],"excerpt":null}},{"slug":"2021-03-25-offsettop-reflow","excerpt":"What forces layout / reflow  라는 문서를 보는데  Getting box metrics  즉  offsetTop ,  getBoundingClientRect()  등을 호출하는 api도 적혀 있었다.\n아니 이게 무슨 소리야...내가 reflow를…","frontmatter":{"title":"OffsetTop을 읽으면 reflow가 발생한다?","date":"2021-03-25T20:38:50+09:00","tags":["Browser","reflow"],"excerpt":null}},{"slug":"2021-03-24-table-of-contents-using-intersection-observer-api","excerpt":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다.","frontmatter":{"title":"Table Of Contents using Intersection Observer API","date":"2021-03-24T23:05:36+09:00","tags":["React","Table Of Contents","Intersection Observer API"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Table Of Contents\\uB294 \\uBAA9\\uCC28\\uB97C \\uC758\\uBBF8\\uD558\\uACE0, Intersection Observer API\\uB294 \\uD0C0\\uAC9F\\uC694\\uC18C\\uAC00 \\uC0C1\\uC704\\uC694\\uC18C(\\uB610\\uB294 viewport)\\uC640 Intersect \\uD558\\uB294\\uC9C0 \\uAD00\\uCC30\\uD558\\uB294 \\uAE30\\uB2A5\\uC744 \\uC81C\\uACF5\\uD558\\uB294 Web API\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다."}}},{"slug":"2021-03-21-prettier-eslint","excerpt":"결론부터 말하자면 오류를 잡으려면 린터, 스타일을 교정하려면 포맷터를 사용하자.","frontmatter":{"title":"prettier와 eslint를 구분해서 사용하자","date":"2021-03-21T21:56:06+09:00","tags":["ESLint","Prettier"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\uACB0\\uB860\\uBD80\\uD130 \\uB9D0\\uD558\\uC790\\uBA74 \\uC624\\uB958\\uB97C \\uC7A1\\uC73C\\uB824\\uBA74 \\uB9B0\\uD130, \\uC2A4\\uD0C0\\uC77C\\uC744 \\uAD50\\uC815\\uD558\\uB824\\uBA74 \\uD3EC\\uB9F7\\uD130\\uB97C \\uC0AC\\uC6A9\\uD558\\uC790.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"결론부터 말하자면 오류를 잡으려면 린터, 스타일을 교정하려면 포맷터를 사용하자."}}},{"slug":"2021-03-21-code-spell-checker","excerpt":"Code Spell Checker는 맞춤법 검사기 for vscode다.","frontmatter":{"title":"Code Spell Checker","date":"2021-03-21T12:13:07+09:00","tags":["vscode"],"excerpt":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Code Spell Checker\\uB294 \\uB9DE\\uCDA4\\uBC95 \\uAC80\\uC0AC\\uAE30 for vscode\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"Code Spell Checker는 맞춤법 검사기 for vscode다."}}},{"slug":"2021-03-14-void(0)","excerpt":"void 드물게 보이는  void(0) 은 뭘까 검색해보니 라고 한다. 재밌는건  void 0 (6 bytes)이  undefined (9 bytes)보다 바이트를 덜 먹기 때문에  uglifyjs 같은 minifier에서  undefined 를  void 0 으로 …","frontmatter":{"title":"void(0)","date":"2021-03-14T14:53:20+09:00","tags":["Javascript"],"excerpt":null}},{"slug":"2021-03-14-finite-state-machine","excerpt":"FSM Finite State Machine(FSM) 은 유한한 개수의 상태를 가질 수 있는 automata이다. 이런 오토마타는  한 번에 오로지 하나의 상태 만을 가지고, 어떠한  event 에 의해 한 상태에서 다른 상태로 변경될 수 있으며 이를  Transit…","frontmatter":{"title":"Finite State Machine","date":"2021-03-14T13:29:14+09:00","tags":["FSM","Finite State Machine"],"excerpt":null}},{"slug":"2021-03-14-screen-capture-api","excerpt":"Screen Capture API 를 통해 화면 또는 화면의 일부를 선택하고 미디어 스트림으로 캡쳐할 수 있다. 화면을 캡쳐하는 API이므로 디바이스의 input을 캡쳐하는  WebRTC API 와 구분이 필요하다. Screen Capture API 사용법 getDi…","frontmatter":{"title":"Screen Capture API","date":"2021-03-14T02:52:32+09:00","tags":["Screen Capture API","Web API"],"excerpt":null}}],"pageInfo":{"currentPage":2,"hasNextPage":true,"hasPreviousPage":true,"itemCount":10,"pageCount":4,"perPage":10,"totalCount":31}}},"pageContext":{"limit":10,"skip":10}},
    "staticQueryHashes": ["1957264973","5457840"]}