{
    "componentChunkName": "component---src-templates-post-list-template-tsx",
    "path": "/page/3",
    "result": {"data":{"allMdx":{"nodes":[{"slug":"2021-03-14-mutation-observer","excerpt":"MutationObserver 는 DOM 변경 감시를 제공한다. DOM을 감시하다가 child 노드들이나 attributes, data 등이 변경되면 콜백을 실행한다.\n예를 들면  prefers-color-scheme  미디어쿼리가  안 먹는 브라우저  에서 다크모드…","frontmatter":{"title":"Mutation Observer","date":"2021-03-14T01:15:29+09:00","excerpt":null,"tags":["Mutation Observer","Web API"]}},{"slug":"2021-03-14-intersection-observer-api","excerpt":"Intersection Observer API 는  타겟 요소 와  상위 요소 or 최상위 Document의 Viewport  사이의 교차점 내의 변화를 비동기적으로 관찰하는 방법이다. 페이지 스크롤에 의한 lazy loading, 무한 스크롤, 스크롤에 따라 강조되…","frontmatter":{"title":"Intersection Observer API","date":"2021-03-14T00:41:42+09:00","excerpt":null,"tags":["Web API","Intersection Observer API"]}},{"slug":"2021-03-13-progressive-web-app","excerpt":"Progressive Web App이란? 웹 앱  : 모든 사람들, 모든 장소, 모든 디바이스에서 접속이 가능하다. 플랫폼 네이티브 앱  : 하드웨어에 접근할 수 있고 기기 데이터와 상호작용할 수 있는 등 장치의 기능을 활용할 수 있다. 설치할 수 있으므로 오프라인에…","frontmatter":{"title":"Progressive Web App","date":"2021-03-13T22:23:32+09:00","excerpt":null,"tags":["Service Worker","PWA"]}},{"slug":"2021-03-13-ecmascript-2021","excerpt":"1.  String.prototype.replaceAll 2.  Promise.any() Promise.all() 이 모든 promise들이 resolve 되면 resolve 되는 함수라면,  Promise.any() 는 하나라도 resolve 된다면 resolve …","frontmatter":{"title":"ECMAScript 2021","date":"2021-03-13T20:25:15+09:00","excerpt":null,"tags":["ECMAScript"]}},{"slug":"2021-03-09-web-worker-service-worker","excerpt":"브라우저는 자바스크립트를 실행하기 위해서  싱글 스레드 를 사용하므로 거대한 자바스크립트 코드를 돌리면 메인 스레드가 block 되고 사용자 경험이 악화될 것이다. 앱에서 다중 스레딩 모델을 사용하는 것 처럼, 웹에서는  Worker 를 사용해서 백그라운드 스레드에서…","frontmatter":{"title":"Web Worker와 Service Worker","date":"2021-03-09T23:15:32+09:00","excerpt":null,"tags":["Service Worker","Web Worker"]}},{"slug":"2021-03-09","excerpt":"주요 metrics(지표) 항목 ⭐️ 표시는  Web Vital 에서 중점적으로 체크하는 항목이다. LCP  : 로딩 성능 FID  : 상호 작용력 CLS  : 시각적 안정성 TTFB (Time To First Byte) 페이지를 요청했을 때 서버에서 데이터의 첫 번째…","frontmatter":{"title":"웹사이트 성능 메트릭","date":"2021-03-09T00:14:35+09:00","excerpt":null,"tags":["Performance","Optimization","Metrics"]}},{"slug":"2021-03-08","excerpt":"브라우저 아키텍처 \n브라우저 엔진 : 유저 인터페이스와 렌더링 엔진 사이의 중개자로, 유저 인터페이스에서 받은 입력에 따라 렌더링 엔진을 쿼리하고 처리한다.\n렌더링 엔진 : HTML/CSS를 파싱해서 사용자가 요청한 특정 웹 페이지를 화면에 렌더링하는 역할을 한다. …","frontmatter":{"title":"브라우저 렌더링에 대한 이해와 최적화","date":"2021-03-08T02:08:38+09:00","excerpt":null,"tags":["Browser","Optimization"]}},{"slug":"2021-02-13-framer-motion-react-motion-gesture","excerpt":"framer-motion는 리액트에서 애니메이션과 제스쳐를 쉽게 다룰 수 있도록 해주는 라이브러리다.","frontmatter":{"title":"framer-motion : react를 위한 motion & gesture 라이브러리","date":"2021-02-13T02:14:33+09:00","excerpt":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"framer-motion\\uB294 \\uB9AC\\uC561\\uD2B8\\uC5D0\\uC11C \\uC560\\uB2C8\\uBA54\\uC774\\uC158\\uACFC \\uC81C\\uC2A4\\uCCD0\\uB97C \\uC27D\\uAC8C \\uB2E4\\uB8F0 \\uC218 \\uC788\\uB3C4\\uB85D \\uD574\\uC8FC\\uB294 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tags":["React","Framer Motion"]}},{"slug":"2021-02-11-webpack-snowpack","excerpt":"스노우팩은 unbundled during development 즉 개발중에 번들링을 하지 않겠다는 컨셉의 프론트엔트 빌드툴이다.","frontmatter":{"title":"Webpack 보다 더 빠른 빌드툴, Snowpack","date":"2021-02-11T04:03:33+09:00","excerpt":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\uC2A4\\uB178\\uC6B0\\uD329\\uC740 unbundled during development \\uC989 \\uAC1C\\uBC1C\\uC911\\uC5D0 \\uBC88\\uB4E4\\uB9C1\\uC744 \\uD558\\uC9C0 \\uC54A\\uACA0\\uB2E4\\uB294 \\uCEE8\\uC149\\uC758 \\uD504\\uB860\\uD2B8\\uC5D4\\uD2B8 \\uBE4C\\uB4DC\\uD234\\uC774\\uB2E4.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tags":["esbuild","Snowpack"]}},{"slug":"2021-02-08-imported-constant-mock","excerpt":"함수를 mock 하는 법은 많은데 의외로 import 된 상수를 mock 하는 방법을 찾기 어려웠다.\n (아니면 그냥 내가 검색을 못하는 걸 수도...) 예를 들면 아래와 같은 코드에서  modeToText  함수를 테스트 하는 경우  isProduction 를 mo…","frontmatter":{"title":"imported constant를 mock 하는 법","date":"2021-02-08T01:43:13+09:00","excerpt":null,"tags":["Jest","test"]}}],"pageInfo":{"currentPage":3,"hasNextPage":false,"hasPreviousPage":true,"itemCount":10,"pageCount":3,"perPage":10,"totalCount":30}}},"pageContext":{"limit":10,"skip":20}},
    "staticQueryHashes": ["1957264973","5457840"]}