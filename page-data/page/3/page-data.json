{
    "componentChunkName": "component---src-templates-post-list-template-tsx",
    "path": "/page/3",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"slug":"/post/2021-03-24-table-of-contents-using-intersection-observer-api","excerpt":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다. 구현해야 할 기능과 방법을 생각해보면 글에서 헤더(h1…","frontmatter":{"title":"Table Of Contents using Intersection Observer API","date":"2021-03-24T23:05:36+09:00","tags":["React","Table Of Contents","Intersection Observer API"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Table Of Contents는 목차를 의미하고, Intersection Observer API는 타겟요소가 상위요소(또는 viewport)와 Intersect 하는지 관찰하는 기능을 제공하는 Web API다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-03-21-prettier-eslint","excerpt":"Prettier와 eslint Prettier는 formatter고 eslint는 linter이다. 두 개의 차이점과 사용법을 알아야 더 스마트하게 사용할 수 있다. 개취지만 포맷팅 안 된 코드 상종 안 한다. (SI 다닐때 정말 힘들었...) 결론부터 말하자면 오류…","frontmatter":{"title":"prettier와 eslint를 구분해서 사용하자","date":"2021-03-21T21:56:06+09:00","tags":["ESLint","Prettier"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"결론부터 말하자면 오류를 잡으려면 린터, 스타일을 교정하려면 포맷터를 사용하자."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-03-21-code-spell-checker","excerpt":"Code Spell Checker는 맞춤법 검사기 for vscode이다. 과제를 평가하다보면 가끔 코드에 오타가 보이곤 한다. 이런 오타들은 코드의 신뢰성을 떨어트리고, typescript를 사용하지 않는 경우 오타 때문에 헤메는 경우가 있다. 하지만 우리는 한국인…","frontmatter":{"title":"Code Spell Checker","date":"2021-03-21T12:13:07+09:00","tags":["vscode"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Code Spell Checker는 맞춤법 검사기 for vscode다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-03-14-void(0)","excerpt":"void 드물게 보이는 void(0)은 뭘까 검색해보니 라고 한다. 재밌는건 void 0(6 bytes)이 undefined(9 bytes)보다 바이트를 덜 먹기 때문에 uglifyjs같은 minifier에서 undefined를 void 0으로 바꾸는 경우가 있는 것…","frontmatter":{"title":"void(0)","date":"2021-03-14T14:53:20+09:00","tags":["Javascript"],"excerptAst":null}},{"slug":"/post/2021-03-14-finite-state-machine","excerpt":"FSM Finite State Machine(FSM)은 유한한 개수의 상태를 가질 수 있는 automata이다. 이런 오토마타는 한 번에 오로지 하나의 상태만을 가지고, 어떠한 event에 의해 한 상태에서 다른 상태로 변경될 수 있으며 이를 Transition이라고…","frontmatter":{"title":"Finite State Machine","date":"2021-03-14T13:29:14+09:00","tags":["FSM","Finite State Machine"],"excerptAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Finite State Machine(FSM)"}]},{"type":"text","value":"은 유한한 개수의 상태를 가질 수 있는 automata이다."}]}],"data":{"quirksMode":false}}}},{"slug":"/post/2021-03-14-screen-capture-api","excerpt":"Screen Capture API를 통해 화면 또는 화면의 일부를 선택하고 미디어 스트림으로 캡쳐할 수 있다. 화면을 캡쳐하는 API이므로 디바이스의 input을 캡쳐하는 WebRTC API와 구분이 필요하다. Screen Capture API 사용법 getDispl…","frontmatter":{"title":"Screen Capture API","date":"2021-03-14T02:52:32+09:00","tags":["Screen Capture API","Web API"],"excerptAst":null}},{"slug":"/post/2021-03-14-resize-observer-api","excerpt":"Resize Observer API는 요소의 크기 변화를 감지하고 콜백을 실행한다. 기존에는 Viewport 크기 변화는 window의 resize 이벤트 또는 window.matchMedia로 감지할 수 있지만 요소의 크기 변화를 직접적으로 감지할 수 있는 방법은 …","frontmatter":{"title":"Resize Observer API","date":"2021-03-14T01:32:43+09:00","tags":["Resize Observer API","Web API"],"excerptAst":null}},{"slug":"/post/2021-03-14-mutation-observer","excerpt":"MutationObserver는 DOM 변경 감시를 제공한다. DOM을 감시하다가 child 노드들이나 attributes, data 등이 변경되면 콜백을 실행한다. 예를 들면 prefers-color-scheme 미디어쿼리가 안 먹는 브라우저 에서 다크모드를 적용하…","frontmatter":{"title":"Mutation Observer","date":"2021-03-14T01:15:29+09:00","tags":["Mutation Observer","Web API"],"excerptAst":null}},{"slug":"/post/2021-03-14-intersection-observer-api","excerpt":"Intersection Observer API는 타겟 요소와 상위 요소 or 최상위 Document의 Viewport 사이의 교차점 내의 변화를 비동기적으로 관찰하는 방법이다. 페이지 스크롤에 의한 lazy loading, 무한 스크롤, 스크롤에 따라 강조되는 tab…","frontmatter":{"title":"Intersection Observer API","date":"2021-03-14T00:41:42+09:00","tags":["Web API","Intersection Observer API"],"excerptAst":null}},{"slug":"/post/2021-03-13-progressive-web-app","excerpt":"Progressive Web App이란? 웹 앱 : 모든 사람들, 모든 장소, 모든 디바이스에서 접속이 가능하다. 플랫폼 네이티브 앱 : 하드웨어에 접근할 수 있고 기기 데이터와 상호작용할 수 있는 등 장치의 기능을 활용할 수 있다. 설치할 수 있으므로 오프라인에서도…","frontmatter":{"title":"Progressive Web App","date":"2021-03-13T22:23:32+09:00","tags":["Service Worker","PWA"],"excerptAst":null}}],"pageInfo":{"currentPage":3,"pageCount":4,"hasNextPage":true,"hasPreviousPage":true}}},"pageContext":{"limit":10,"skip":20}},
    "staticQueryHashes": ["1957264973","5457840"]}