---
title: "[LeetCode] 1331. Rank Transform of an Array"
date: 2020-05-16T11:58:02+09:00
tags: [Algorithm, LeetCode, Array]
---

# Problem

> Given an array of integers arr, replace each element with its rank.  
> The rank represents how large the element is. The rank has the following rules:  
>
> - Rank is an integer starting from 1.
> - The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
> - Rank should be as small as possible.
>
> 주어진 정수 배열의 요소들을 해당 요소의 순위로 대체해라.  
> 순위는 요소가 얼마나 큰지를 나타낸다. 순위는 다음 규칙을 따른다:
>
> - 순위는 1부터 시작하는 정수이다.
> - 요소가 클 수록 순위도 크다. 두 수가 같으면, 순위도 같아야 한다.
> - 순위는 가능한 작아야 한다.

```
Example 1:
Input: arr = [40,10,20,30]
Output: [4,1,2,3]
Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.

Example 2:
Input: arr = [100,100,100]
Output: [1,1,1]
Explanation: Same elements share the same rank.

Example 3:
Input: arr = [37,12,28,9,100,56,80,5,12]
Output: [5,3,4,2,8,6,7,1,3]

Constraints:
0 <= arr.length <= 105
-109 <= arr[i] <= 109
```

# Solution

[rank-elements-array](https://www.geeksforgeeks.org/rank-elements-array/)

t라는 튜플 배열을 만드는데, 이 배열은 각 요소의 (value, index)를 저장한다. 그리고 이 배열을 요소값 순으로 정렬한다. 정렬되면, 동일한 요소들이 인접하게 된다. 그 후 t를 순회하면서 인접한 요소가 없는 경우를 찾고 각각의 순위를 찾으면 된다.

시간 복잡도 $O(N\log N)$

```py
def array_rank_transform(arr):
    l = len(arr)
    rank = [0] * l
    t = [(i, j) for j, i in enumerate(arr)]  # (val, idx)
    t.sort(key=lambda x: x[0])  # sort by value
    r, n, i = 1, 1, 0
    while i < l:
        j = i
        while j < l - 1 and t[j][0] == t[j + 1][0]: # 같은 값 끝 index 찾기
            j += 1
        n = j - i + 1  # 값이 같은 갯수
        for k in range(n):
            # t[i + k][1] : 같은 값의 원래 위치 (index)
            rank[t[i + k][1]] = r
        r += 1
        i += n
    return rank
```
