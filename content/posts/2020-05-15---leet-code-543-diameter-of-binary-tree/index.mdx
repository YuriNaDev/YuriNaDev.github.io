---
title: "[LeetCode] 543. Diameter of Binary Tree"
date: 2020-05-15T16:32:59+09:00
tags: [Algorithm, LeetCode, Tree, Binary Tree]
---

# Problem

> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
>
> 이진 트리가 주어지면 트리의 지름 길이를 계산해야 한다. 이진 트리의 지름은 임의의 두 노드 사이의 가장 긴 경로의 길이다. 이 경로는 루트를 지날 수도 지나지 않을 수도 있다.

```
Example:
Given a binary tree
          1
         / \
        2   3
       / \
      4   5
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
```

# Solution

각 노드에서 왼쪽 서브트리에서 구한 지름값과 오른쪽 서브트리에서 구한 지름값과 높이를 계산한다. 각 각 노드에서는 현재 노드에서 양 옆의 높이를 더한 값과 양쪽 서브트리에서 구한 지름값들 중 큰 값을 지름으로 반환한다. 높이의 경우 양 옆의 높이 중 큰 값에 1을 더해서 반환한다. 노드가 없는 경우 지름값과 높이 모두 0을 반환한다.

예제에서 1번 노드의 경우라고 할 때, 왼쪽 서브트리는 지름 2(4-2-5), 높이 2를 반환하고, 오른쪽 서브트리는 지름 0, 높이 1을 반환한다.  
따라서 이 노드에서 반환하는 지름을 선택할때는

1. 왼쪽 서브트리의 지름 2 (4-2-5)
2. 오른쪽 서브트리의 지름 0
3. 양측 서브트리 높이의 합 3 (4-2-1-3 or 5-2-1-3)

이 중에서 가장 값이 큰 값을 취하면 되는 것이다.

시간 복잡도 $O(N)$

```py
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def diameter_util(node):
    if not node:
        return 0, 0
    ld, lh = diameter_util(node.left)
    rd, rh = diameter_util(node.right)
    return max(lh + rh, ld, rd), max(lh, rh) + 1


def diameter(root):
    d, h = diameter_util(root)
    return d


if __name__ == '__main__':
    tree = TreeNode(1)
    tree.left = TreeNode(2)
    tree.left.left = TreeNode(4)
    tree.left.right = TreeNode(5)
    tree.right = TreeNode(3)
    print(diameter(tree))
```
