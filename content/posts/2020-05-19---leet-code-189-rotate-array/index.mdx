---
title: "[LeetCode] 189. Rotate Array"
date: 2020-05-19T14:47:42+09:00
tags: [Algorithm, LeetCode, Array, Hash Table]
series: Top Interview Question (Easy) - Array
---

# Problem

> Given an array, rotate the array to the right by k steps, where k is non-negative.
>
> 배열이 주어지면 배열을 오른쪽으로 k번 밀어라. k는 음수가 아니다.

```
Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

Constraints:
- 1 <= nums.length <= 2 * 10^4
- It's guaranteed that nums[i] fits in a 32 bit-signed integer.
- k >= 0
```

# Solution

배열의 요소로 $n$을 가지고 있고 $k$가 필요한 shift 수라고 가정한다. 또한 $n\%k=0$, $n\%k=0$을 가정한다. 이제, 우리가 원소를 올바른 위치에 놓기 시작할 때, 첫 번째 사이클에서 $i\%k=0$을 만족하는 모든 수가 필요한 위치에 배치된다. $i=0$에서 시작했으므로, $i\%k=0$도 만족한다. 따라서 위 조건을 만족하는 모든 수를 첫 번째 사이클에서 방문하게 된다. 원래 위치에 도달했을 때, 우리는 $\frac n k$개의 요소가 정위치에 놓이게 된다. 이제 인덱스를 하나 증가시키면, $i\%k=1$인 모든 수를 방문하게 된다. 이 과정은 $i\%k=0$에 도달할 때 까지 반복되며 $k$사이클 후에 도달한다. 총 바꾸기 횟수는 $k * \frac n k = n$회가 된다.

시간 복잡도 $O(N)$  
공간 복잡도 $O(1)$

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k %= n
        start = count = 0
        while count < n:
            curr, prev = start, nums[start]
            while True:
                next_idx = (curr + k) % n
                nums[next_idx], prev = prev, nums[next_idx]
                curr = next_idx
                count += 1
                if start == curr:
                    break
            start += 1


s = Solution()
arr = [1, 2, 3, 4, 5, 6, 7]
s.rotate(arr, 3)
print(arr)
arr = [-1, -100, 3, 99]
s.rotate(arr, 2)
print(arr)
arr = [1, 2]
s.rotate(arr, 0)
print(arr)
arr = [1, 2, 3, 4, 5, 6]
s.rotate(arr, 4)
print(arr)
```
