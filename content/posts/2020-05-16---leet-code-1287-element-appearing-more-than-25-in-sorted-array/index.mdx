---
title: "[LeetCode] 1287. Element Appearing More Than 25% In Sorted Array"
date: 2020-05-16T10:38:55+09:00
tags: [Algorithm, LeetCode, Array]
---

# Problem

> Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time.  
> Return that integer.
>
> 오름차순으로 정렬된 정수 배열이 주어지고, 그 중 하나의 정수가 25% 이상의 빈도로 나타난다.  
> 그 수를 반환해라.

```
Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6

Constraints:
1 <= arr.length <= 10^4
0 <= arr[i] <= 10^5
```

# Solution

배열의 길이를 4로 나누고, 각 구간의 시작점에 있는 정수가 어느 시점부터 어느 시점까지 나타나는지 확인한다. 끝점과 시작점의 차이가 n보다 크면 해당 정수를 반환한다.

시간 복잡도 $O(N\log N)$

```py
"""
bisect.bisect : 반환값 i는 배열을 x보다 작거나 같은 배열 / x보다 큰 배열 두개로 나누는 index 값
bisect.bisect_left : 반환값 i는 배열을 x보다 작은 배열 / x보다 크거나 같은 배열 두개로 나누는 index 값
"""


def find_special_integer(arr):
    import bisect
    n = len(arr) // 4
    for i in range(0, len(arr), n + 1):
        start = bisect.bisect_left(arr, arr[i])
        end = bisect.bisect(arr, arr[i])
        if end - start > n:
            return arr[i]


if __name__ == '__main__':
    print(find_special_integer([1, 2, 2, 6, 6, 6, 6, 7, 10]))
```

# Follow Up

**Sliding Window Technique**

슬라이딩 윈도우 알고리즘은 일정한 범위를 가지고 있는 것을 유지하면서 이것을 이동하는 것이다. 이 문제에서는 배열의 길이의 1/4를 일정한 범위로 유지하면서 범위의 시작점과 끝점이 같은지 확인하면 된다.

시간 복잡도 $O(N)$

```py
def find_special_integer(arr):
    lo, hi = 0, len(arr) // 4
    while lo < hi:
        if arr[lo] != arr[hi]:
            lo += 1
            hi += 1
        else:
            break
    return arr[lo]


if __name__ == '__main__':
    print(find_special_integer([1, 2, 2, 6, 6, 6, 6, 7, 10]))
```
