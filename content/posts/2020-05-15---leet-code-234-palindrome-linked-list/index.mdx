---
title: "[LeetCode] 234. Palindrome Linked List"
date: 2020-05-15T13:26:24+09:00
tags: [Algorithm, LeetCode, Linked List, Two Pointers]
---

# Problem

> Given a singly linked list, determine if it is a palindrome.
>
> 연결 리스트가 주어졌을때, 팰린드롬인지 판단해라.  
> **참고 :** 팰린드롬이란 좌우 반전해도 같은 배열이다.

```
Example 1:
Input: 1->2
Output: false

Example 2:
Input: 1->2->2->1
Output: true
```

# Solution

1. 두 개의 포인터를 이용해 fast는 두 칸씩 이동하고, slow는 다음 노드를 가리키는 head로 변경하고, 동시에 다음 연결 노드를 현재 slow로 변경하고, 마지막으로 head를 한 칸 이동시킨다. 이와 같이 진행하면 slow와 head로 인해 리스트가 한 칸씩 reverse 된다.
2. fast 또는 fast.next가 null이면 루프를 종료한다. fast는 두 칸씩 이동했으므로 slow, head는 반절을 이동하게 된다.
   - `1->2->3->4->5->6->7` 이라는 리스트가 주어지면, 첫 루프 실행시 head는 `4->5->6->7`의 `4`에 위치하게 되고, mid는 `5->6->7`의 `5`에 위치하게 되고, slow는 `3->2->1`의 `3`에 위치하게 된다.
3. slow와 mid를 순차적으로 비교하면서 전부 일치하는지 확인한다.

시간 복잡도 $O(N)$  
공간 복잡도 $O(1)$

```py
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


def is_palindrome(head):
    slow, fast = None, head
    while fast and fast.next:
        fast = fast.next.next
        slow, slow.next, head = head, slow, head.next
    mid = head.next if fast else head
    while slow:
        if slow.val != mid.val:
            return False
        slow, mid = slow.next, mid.next
    return True


if __name__ == '__main__':
    head1 = ListNode(1)
    head1.next = ListNode(2)
    print(is_palindrome(head1))
    head2 = ListNode(1)
    head2.next = ListNode(2)
    head2.next.next = ListNode(2)
    head2.next.next.next = ListNode(1)
    print(is_palindrome(head2))
```
