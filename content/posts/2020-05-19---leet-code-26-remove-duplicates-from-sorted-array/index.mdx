---
title: "[LeetCode] 26. Remove Duplicates from Sorted Array"
date: 2020-05-19T13:21:37+09:00
tags: [Algorithm, LeetCode, Array, Two Pointers]
series: Top Interview Question (Easy) - Array
---

# Problem

> Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  
> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
>
> 정렬된 숫자 배열이 주어지면 숫자가 하나만 나타나도록 in-place로 중복된 숫자를 지우고 새로운 길이를 반환해라.  
> 다른 배열에 추가 공간을 할당하지 말고 추가 메모리 대신 입력 배열을 수정하여 작업을 수행해야 한다.

```
Example 1:
Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the returned length.

Example 2:
Given nums = [0,0,1,1,1,2,2,3,3,4],
Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.
It doesn't matter what values are set beyond the returned length.
```

# Solution

포인터 2개를 정의하고, fast 포인터는 배열의 처음부터 끝까지 흝는다고 하자. slow 포인터의 경우 fast 포인터가 가리키는 값과 slow 포인터가 가리키는 값이 다를때 slow가 가리키는 값을 새로운 값으로 대체한다. 이렇게 하면 앞에 중복되지 않은 숫자들이 차례로 쌓이게 된다. 마지막으로 slow 포인터와 fast 포인터의 차이만큼 배열 뒤를 pop으로 삭제한다.

시간 복잡도 $O(N)$  
공간 복잡도 $O(1)$

```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        n = len(nums)
        while fast < n:
            if nums[slow] == nums[fast]:
                fast += 1
            else:
                slow += 1
                nums[slow] = nums[fast]
                fast += 1
        slow += 1
        while slow < fast:
            nums.pop()
            slow += 1
        return len(nums)


s = Solution()
print(s.removeDuplicates([1, 1, 2]))
print(s.removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]))
print(s.removeDuplicates([0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 4, 5, 5, 5, 6]))
```
